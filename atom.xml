<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祁宏涛</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-10T05:31:53.636Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QHT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(QT) C++学习之路之——计算器的实现</title>
    <link href="http://yoursite.com/2018/09/10/C++%E7%89%88%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/09/10/C++版本计算器实现/</id>
    <published>2018-09-10T05:10:00.000Z</published>
    <updated>2018-09-10T05:31:53.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QT-C-学习之路之——计算器的实现"><a href="#QT-C-学习之路之——计算器的实现" class="headerlink" title="(QT) C++学习之路之——计算器的实现"></a>(QT) C++学习之路之——计算器的实现</h2><p>在学校一直学习的是 Android 应用开发，入职后公司要求转C++(QT) 开发，嫁鸡随鸡。同时公司给新员工有几门培训课程，而每门课都有作业，这篇文章便是“数据结构”这门课的作业说明。</p>
<p><strong>PS：控制台的计算器实现，C++代码，可进行加减乘除四则运算，支持<font color="red" size="3">负数</font>和<font color="red" size="3">小数</font>运算。</strong></p>
<hr>
<p><strong><strong>本计算器的主要特点为：</strong></strong></p>
<ol>
<li>自定义栈和单链表。</li>
<li>提供顶层计算接口，由实现类完成具体计算方法，易扩展。</li>
<li>利用简单工厂模式实现计算器的计算部分。</li>
<li>通过栈的特性进行四则运算表达式的括号匹配。</li>
<li>抽取Check类，完成输入表达式的正确性校验，复用性强。</li>
</ol>
<p><strong><strong>本计算器的主要思想过程为：</strong></strong></p>
<ul>
<li>首先对输入的表达式进行非法校验，如果输入非法，提示用户重新输入。</li>
<li>然后将中缀表达式转化为后缀表达式，并对负号和减号进行区分，消除括号，只保留数字和运算符。</li>
<li>其次对后缀表达式中的小数点、非个位数进行处理，转化为数字。</li>
<li>再次依次出栈根据不同的运算符进行计算。</li>
<li>最后得出结果并打印。</li>
</ul>
<hr>
<p><strong>JSQ_C++.cpp</strong></p>
<blockquote>
<pre><code>本文件为主函数入口，通过调用计算器的run方法启动计算器。
</code></pre></blockquote>
<p><strong>JSQ.cpp</strong></p>
<blockquote>
<p>本文件封装了计算器的核心算法思想，提供三个方法，</p>
<ul>
<li>mid2Behind方法：将输入的中缀表达式转换为后缀表达式（逆波兰表达式）。</li>
<li>readNumber方法：将后缀表达式中的字符处理为数字（包含小数点和非个位数字处理）。</li>
<li>caculate  方法：利用工厂方法产出计算结果。</li>
</ul>
</blockquote>
<p><strong>OptionerFactory.cpp</strong></p>
<blockquote>
<pre><code>本文件是操作符的生产类，根据传入参数生产不同的操作符对象。
</code></pre></blockquote>
<p><strong>Check.cpp</strong></p>
<blockquote>
<pre><code>本文件只暴露一个public的check方法，供外部调用，进行输入非法校验。
其余还包含4个或更多的private方法，实现具体的判断逻辑，返回结果给public的check方法。
</code></pre></blockquote>
<p><strong>Util.cpp</strong></p>
<blockquote>
<pre><code>本文件提供一系列的static方法，无关对象，只可访问，不可修改，任何人可以调用。
具体实现是一些常见的工具类。
</code></pre></blockquote>
<p><strong>IOperation.h</strong></p>
<blockquote>
<pre><code>本文件是操作符的上层接口，只提供一个getResult方法，由加减乘除实现类去实现。
</code></pre></blockquote>
<p><strong>ADD.cpp  SUB.cpp  MUI.cpp  DIV.cpp  MOD.cpp</strong></p>
<blockquote>
<pre><code>这五个文件为具体的运算类，实现了IOperation接口，进行具体的二元运算。
</code></pre></blockquote>
<p><strong>SLList.h</strong></p>
<blockquote>
<pre><code>自定义的单链表，包含一个节点类和一个链表类，实现了链表常见的插入和删除操作。
由于属于模板类，因此声明和定义只能放到一个文件中。
</code></pre></blockquote>
<p><strong>StackDIY.h</strong></p>
<blockquote>
<pre><code>使用SLList实现的栈，实现了常见的压栈、出栈、取栈顶元素等操作。
</code></pre></blockquote>
<hr>
<ul>
<li>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a></li>
<li>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a></li>
<li>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a></li>
<li>代码下载地址:<a href="https://download.csdn.net/download/u012534831/10656676" target="_blank" rel="external">https://download.csdn.net/download/u012534831/10656676</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      https://qht1003077897.github.io/
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="http://yoursite.com/2018/01/07/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/07/2017年终总结/</id>
    <published>2018-01-07T14:10:00.000Z</published>
    <updated>2018-01-08T01:19:25.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2017年终总结"><a href="#2017年终总结" class="headerlink" title="2017年终总结"></a>2017年终总结</h1><p>也不是跟自媒体的风，个人认为写个总结报告确实很有必要。一来是对过去一年的回顾与总结，二来是对来年学习，工作，生活的展望与规划。</p>
<p><strong>一、学习和工作。总结一下共干了这么几件事:</strong></p>
<ul>
<li>3月份一是搭建了自己的个人博客，依靠github page ，地址：<a href="https://github.com/qht1003077897，本来是计划写各种生活感想啦等等，但是最后全写了技术总结，尴尬。里面有教程，想要玩的可以自己去耍一耍。二是第一次因为工作去北京出差，见到了项目实施的完整过程，见识了很多。" target="_blank" rel="external">https://github.com/qht1003077897，本来是计划写各种生活感想啦等等，但是最后全写了技术总结，尴尬。里面有教程，想要玩的可以自己去耍一耍。二是第一次因为工作去北京出差，见到了项目实施的完整过程，见识了很多。</a></li>
<li>4月份开源了自己的第一个项目H-Express，托管在github 上，这是对自己2年安卓开发经验的总结与检验，一是练习一下一些有但是没有实践过的想法，二是想通过实际操作探索一下架构的门槛。但是最后因为时间原因也没搞完，80%左右。</li>
<li>5、6月份也忘了自己干啥了，一是解决项目上的遗留问题，二是慢慢开始做复习的工作，好像在leetcode 上刷了6，7道题吧，没坚持下来。。。。</li>
<li>7，8月份一是为找工作准备，意识到源码的重要性，主演在学习源码。二是考虑论文方向，查资料。三是筹备并报名参加了几个比赛。四是帮某个老师做了个小项目。</li>
<li>9月份就开始找工作了，答题、笔试、面试，最终在月底敲定工作，坐标西安。</li>
<li>10月份一是开始做另一个项目，研二安卓端断层，么办法，老骥伏枥。二是月底第一次参加了某比赛的全国总决赛，最终得到二等奖，憾负第一。三是写了小论文，完成考核并对毕业论文的各方面有了了解。</li>
<li>11月份就一直再做项目，主要时间花在了研究音频转红外的技术难点上，有付出就有回报，软件层面的问题基本解决，学到了很多。</li>
<li><p>12月份也一直在做项目，一个人苦苦支撑，应对各种问题，希望最迟18年元月底能搞完，都累呀。</p>
</li>
<li><p>总结：<br>技术方面学到了不少，但是也不多，没有16年那种明显进步的感觉，感觉自己有种碰到困难逃避的现象，做不到强迫自己花定量的时间去研究问题，还是有点心浮气躁。希望18年自己敢于直面困难，多接触新知识敢于研究并学习。</p>
</li>
<li><p>计划：<br>1、在18年掌握一定的c++知识，看完c++ primer ，因为这是公司发来的书单的一本。<br>2、全面学习源码，深入framework ，这也是公司要求的一部分，难点，要敢于攻克。<br>3、自己学习一定的html5，配合混合app ，毕竟这是现状要求。<br>4、敢于承担，18年踏入工作，即踏入社会，不敢承担，只能做最底层。<br>5、规划时间，作息规律，对身体负责。</p>
</li>
</ul>
<p><strong>二、感情与生活，说大了就是一件事，和倩倩童鞋的一年:</strong></p>
<ol>
<li>2017年是我们度过的第一个完整的一年，很幸运遇到她，她很好，非常非常好。正如前任3讲的一样，在刚刚好的时间遇到对的人，我也别无他求。一年中在她的脸上见过甜蜜的笑容，但也尝过生气的冷漠。在感情这条路上，我们彼此欣赏，共同学习，是她让我懂得珍惜，是她让我改掉一些坏毛病与脾气，是她陪着我成长。她始终信任我，相信我有点大男子主义的一堆大道理。真的，感谢倩倩童鞋2017稳稳的陪伴与爱，我也爱你。希望倩倩童鞋少加班，一年都健健康康，每天能开开心心，2018，我们共同加油！</li>
</ol>
]]></content>
    
    <summary type="html">
    
      https://qht1003077897.github.io/
    
    </summary>
    
      <category term="生活笔记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>安卓实现耳机口音频转红外发射</title>
    <link href="http://yoursite.com/2017/12/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%AE%9E%E7%8E%B0%20%E5%AE%89%E5%8D%93%E8%80%B3%E6%9C%BA%E5%8F%A3%E9%9F%B3%E9%A2%91%E8%BD%AC%E7%BA%A2%E5%A4%96%E5%8F%91%E5%B0%84/"/>
    <id>http://yoursite.com/2017/12/11/手把手教你学习并实现 安卓耳机口音频转红外发射/</id>
    <published>2017-12-11T14:00:16.000Z</published>
    <updated>2017-12-11T14:18:31.124Z</updated>
    
    <content type="html"><![CDATA[<p>###安卓实现耳机口音频转红外发射</p>
<p>前一段时间因为找工作，完了之后又有两个项目做，一个 BLE4.0 的项目，一个红外控制的项目，因此也好久没写文章了。BLE4.0 的资料网上一抓一大把，就不多说了。</p>
<p>虽说红外很早就开始火了，从最早的遥控器，到红外测距等等，但是网上关于 Android 红外开发的相关资料几乎没有。那就只能硬着头皮自己上。</p>
<p>手机自带红外有 ConsumerIrManager 类，很好用，略过。而我们今天看的是另一种红外发送方式：<font color="#ff0000" size="3" face="微软雅黑">音频转红外</font>。</p>
<hr>
<p><strong>1、相关知识介绍：</strong></p>
<p><img src="http://img.blog.csdn.net/20171207101223410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 这是网上找的格力空调的开机短码，将这些数字理解成一个 TA 自己规定的协议，9000，4500 为帧头，560,1690 代表 1，560,560 代表 0。先不管帧头，剩下的翻译过来就是{1,0,1,0 , 1,0,1,0，0,1,0,1，0,1,0,1}，再翻译为16进制，即为0xAA，0x55，这是一个开机命令。</p>
<p><em>注：<a href="http://read.pudn.com/downloads66/sourcecode/embed/236793/IR/%E9%81%A5%E6%8E%A7%E5%99%A8%E5%8E%9F%E7%90%86.pdf" target="_blank" rel="external">红外遥控器原理和NEC协议</a>，<font color="black" size="3" face="“楷体”">这里面有相关的知识，建议先阅读。</font></em></p>
<hr>
<p>采样率 44100：通俗理解就是  在1s内在一条连续的正玄波上面采集 44100 个点。<br>载波 38KHZ：  即为我们发出的音频信号需要放在 38KHZ 的载波上才能发送出去被红外接收头接收。</p>
<font color="#ff0000" size="3" face="微软雅黑">音频转红外要做的就是生成 PCM（单/双声道）数据，即为音频数据，按照硬件支持的 NEC 协议，指定采样率，指定载波，使用 Android SDK 中的 audioTrack 类播放这段音频即可</font>。<br><br><img src="http://img.blog.csdn.net/20171207105650197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br><em>注：<a href="http://www.cnblogs.com/CoderTian/p/6657844.html" target="_blank" rel="external">多媒体基础知识之PCM数据</a>，<font color="black" size="3" face="“楷体”">这里面有 PCM 相关的知识，包括采样率、载波等。</font></em>

<p><em>注：<font color="black" size="3" face="“楷体”">硬件自己焊接或者淘宝：android 音频红外发射头，附<a href="http://bbs.vivo.com.cn/thread-2252423-1-1.html" target="_blank" rel="external">焊接教程</a></font></em></p>
<hr>
<p><strong>2、音频调试：</strong></p>
<p>音频调试我使用的电脑软件 cooledit，百度一下就有免费的，再加一根3.5mm 的公对公耳机线。</p>
<p><img src="http://img.blog.csdn.net/20171207110931614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20171207110858841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li><p>step1：使用遥控精灵搜到你的空调型号。</p>
</li>
<li><p>step2：公头线一头插耳机口，一头插电脑音频 mic 口，手机音量调到最大，并在电脑上打开 cooledit 软件。</p>
</li>
<li><p>step3：点击 cooledit 的录音键，选择采样率 44100，双声道，16 位。打开遥控精灵，打到你的空调按钮面板，连续点击几次开机键。</p>
</li>
<li><p>step4：可以看到 cooledit 软件界面上有一些绿色的声音波形。</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171207112851831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上面这张图片是我抓的遥控精灵发出的电平信号，可以看到 9ms 的高电平和 4.5ms 的低电平，虽然看到这儿是方波，但是再往后其实 TA 也是正玄波。高电平这儿全部是标准的正玄波组成的，宽度为时间宽度 9ms。</p>
<p>那对于我们来说只要仿造出图中那样的波形，9ms高、4.5ms低………….，即可和遥控精灵一样控制我们的空调了。</p>
<p><strong>3、仿造波形：</strong></p>
<p>要仿造一段 20KHZ（因为耳机口只能输出这么大），采样率 44100 , 16 位双声道的 PCM 音频数据，网上还是有点资料可寻的。</p>
<p>目前，我没有找到输出方波的方法，再加上经过对遥控精灵输出波形的观察，也是输出的正玄波，所以就放心的输出 Sin 正玄波吧。</p>
<p>必要了解 ①：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffSize = AudioTrack.getMinBufferSize(this.sampleRate,</div><div class="line">               AudioFormat.CHANNEL_OUT_STEREO,</div><div class="line">               AudioFormat.ENCODING_PCM_16BIT) * 4;</div></pre></td></tr></table></figure>
<p>AudioTrack：音频播放类。<br>sampleRate：采样率。<br>AudioFormat.CHANNEL_OUT_STEREO：双声道输出，即为立体声，但同时也增加了文件大小。<br>AudioFormat.ENCODING_PCM_16BIT：16位，一个采样点占16位。但同时也增加了文件大小。</p>
<p>必要了解 ②：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">y(t) = A * sin (ωt + φ)</div><div class="line"></div><div class="line">//ω即为角速度，在一段周期内转过了多少角度。</div><div class="line">//T为周期。</div><div class="line">//f为频率。</div><div class="line">ω = 2π/T = 2πf  </div><div class="line"></div><div class="line">y(t) = A * sin (2πft + φ)</div></pre></td></tr></table></figure>
<p>正玄波重要函数，</p>
<ul>
<li>A: 振幅，这里为1；</li>
<li>f : 频率，这里为 freqOfTone;（即为19000HZ）</li>
<li>t: 时间，这里为 (i/sampleRate);（当i为44100时是不是就是1s了）</li>
<li>φ: 相位，这里为0；</li>
</ul>
<p>表示下来就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sample[i] = Math.sin(2 * Math.PI  * i * (freqOfTone /sampleRate));</div></pre></td></tr></table></figure></p>
<p>必要了解 ③：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,</div><div class="line">                   this.sampleRate, AudioFormat.CHANNEL_OUT_STEREO,</div><div class="line">                   AudioFormat.ENCODING_PCM_16BIT, bytes1.length,</div><div class="line">                   AudioTrack.MODE_STREAM);</div></pre></td></tr></table></figure>
<p>STREAM_MUSIC：播放类型，有 Alerm、Notification 等。<br>AudioTrack.MODE_STREAM：MODE 有 STREAM 和 STATIC  两种。STREAM 类型意味着音频可以被连续播放，只需要一直往缓冲池写即可。STATIC 通常用于播放游戏音等，适合短小音频。<br>bytes1.length：一次可播放音频文件的缓冲池大小。</p>
<p>核心代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for (final double dVal : sample) &#123;</div><div class="line">   final short val = (short) ((dVal * 32767));</div><div class="line">   final short val_minus = (short) -val;</div><div class="line">   //左声道</div><div class="line">   generatedSnd[idx] = (byte) (val &amp; 0x00ff);</div><div class="line">   generatedSnd[idx+1] = (byte) ((val &amp; 0xff00) &gt;&gt;&gt; 8);</div><div class="line">   //16位双声道  右声道</div><div class="line">   generatedSnd[idx+2] = (byte) (val_minus &amp; 0x00ff);</div><div class="line">   generatedSnd[idx+3] = (byte) ((val_minus &amp; 0xff00) &gt;&gt;&gt; 8);</div><div class="line">   idx=idx+4;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>代码解释：</p>
<p>上面第2行和第3行是将振幅缩放到最大振幅（32767是16位整数的最大值）。</p>
<p>上面第5、6行和第8、9行是填充PCM数据，上面有文章讲了PCM数据格式，在16位wav PCM中，低字节到高字节：<br>|样本大小| 数据格式| 最小值| 最大值|<br>|: ————-|:————-|: —–|: —–|<br>|8位PCM | int |-128|127|<br>| 16位PCM |  int  | -32768  |32767|</p>
<p>填充完毕后，我们就有了完整的正玄波数据。（即高电平正玄波）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;Byte&gt; listByte = new ArrayList&lt;&gt;();</div><div class="line">for (int j = 0; j &lt; patterns.length; j++) &#123;</div><div class="line">    int d=patterns[j];</div><div class="line">    final int points = (int) ((((double) d / 1000000.0) * sampleRate)*4);</div><div class="line">      if (j % 2 == 0) &#123;</div><div class="line">        for (int i = 0; i &lt; points; i++) &#123;</div><div class="line">            listByte.add(generatedSnd[i]);</div><div class="line">        &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">         for (int i = 0; i &lt; points; i++) &#123;</div><div class="line">             listByte.add((byte) 0);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码解释：<br>patterns 即为我们要发送的电平数组，9000 , 4500… 那个。</p>
<p>看第4行，9000是 μs，9000/1000000，是将  μs 转化为秒，再乘sampleRate 即为在9000μs 这段时间内占有多少个采样点。</p>
<p>因为9000为高电平，4500为低电平，再接下来又为高电平，然后又是低电平….所以偶数位为高电平 ，所以偶数位上这 points 个点都为高电平，到奇数位了这 points 个点都为低电平，低电平使用0表示即可。然后将所有的点拼装到一起，组成完成的PCM数据，使用 AudioTrack 播放即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">            audioTrack.play();</div><div class="line">        &#125; catch (IllegalStateException e) &#123;</div><div class="line">            LogUtil.e( e.getMessage());</div><div class="line">        &#125;</div><div class="line">           audioTrack.write(listByte, 0, listByte.length);</div></pre></td></tr></table></figure>
<p>格力空调的控制码网上一搜一大堆，在这里我不会开放源代码，核心代码已经给出了，自己好好理解理解，分析分析，就可以自己写出来了。</p>
<p>这个也是自己花了好长时间才搞定的，所以请尊重他人劳动成果，不做伸手党。当然有不明白的可以在下面留言，欢迎交流，共同学习。</p>
<hr>
<p>my QQ : 1003077897<br>my csdn：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>my  gay：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a></p>
<p>欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      基于红外项目自己摸索学习总结
    
    </summary>
    
      <category term="手把手,无线技术" scheme="http://yoursite.com/categories/%E6%89%8B%E6%8A%8A%E6%89%8B-%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="手把手" scheme="http://yoursite.com/tags/%E6%89%8B%E6%8A%8A%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法-KMP算法</title>
    <link href="http://yoursite.com/2017/07/21/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/21/算法-KMP算法/</id>
    <published>2017-07-21T02:00:16.000Z</published>
    <updated>2017-07-21T07:45:15.034Z</updated>
    
    <content type="html"><![CDATA[<p>KMP算法</p>
<p>字符串匹配是计算机的基本任务之一。</p>
<p>问题：给定一个主字符串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，即串的模式匹配问题。今天来介绍解决这一问题的常用算法之一，Knuth-Morris-Pratt 算法（简称 KMP），这个算法是由Knuth、Morris、Pratt共同提出。</p>
<ul>
<li>时间复杂度：O（m+n） （n为文本串T的长度）</li>
<li>空间复杂度：O（m） （m为模式串P的长度）</li>
</ul>
<p>这个问题有多种解法：</p>
<ul>
<li>蛮力法。</li>
<li>Robin-Karp字符串匹配算法。</li>
<li>基于有限自动机的字符串匹配算法。</li>
<li>Boyce-Moore算法。</li>
<li>后缀树。</li>
</ul>
<p>在继续下面的内容之前，有必要在这里介绍下两个概念：前缀和后缀:<br><img src="http://img.blog.csdn.net/20170720105330877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><font color="#ff0000" size="3px"><b>注意：”hin” 并不是”china”前缀或后缀。</b><font></font></font></p>
<p>以下摘自<font color="#ff0000" size="3px">刘毅</font><a href="http://www.61mon.com/index.php/archives/183/" title="KMP 算法（1）：如何理解 KMP" target="_blank" rel="external">KMP 算法（1）：如何理解 KMP</a>。</p>
<p>###算法思想：</p>
<p>1、首先，主串 “BBC ABCDAB ABCDABCDABDE” 的第一个字符与模式串 “ABCDABD” 的第一个字符，进行比较。因为 B 与 A 不匹配，所以模式串后移一位。</p>
<p><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_2.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>2、因为 B 与 A 又不匹配，模式串再往后移。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_3.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>3、就这样，直到主串有一个字符，与模式串的第一个字符相同为止。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_4.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>4、接着比较主串和模式串的下一个字符，还是相同。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_5.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>5、直到主串有一个字符，与模式串对应的字符不相同为止。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_6.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>6、这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把 “搜索位置” 移到已经比较过的位置，重比一遍。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_7.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"><br>7、一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是 “ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把 “搜索位置” 移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。该算法避免了T中部分元素的再次比较，如果这些元素已经与模式串P中的部分元素比较过。<br><img src="http://oi0fekpsr.bkt.clouddn.com/KMP%E7%AE%97%E6%B3%95_8.png?imageView2/2/w/1440/q/75/format/webp" alt="这里写图片描述"></p>
<p>###前缀表：</p>
<p>&emsp;&emsp;该算法使用一个表F，F通常称为前缀函数、前缀表或失配函数。下面首先介绍如何构造表F，然后阐述如何使用该表进行模式串匹配。<br>&emsp;&emsp;前缀表F中存储了模式串资深如何移动的信息。此信息用来避免模式串P不必要的移动。也就是说，此表用以避免在字符串T中的回溯。</p>
<p>####前缀表算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int[] F;     //全局变量，next数组，也称前缀表</div><div class="line">	private void Prefix_Table(int P[],int m)&#123;</div><div class="line">		int i=1,j=0;F[0]=0;</div><div class="line">		while(i&lt;m)&#123;</div><div class="line">			if(P[i]==P[j])&#123;</div><div class="line">					F[i]=j+1;</div><div class="line">					i++;</div><div class="line">					j++;</div><div class="line">			&#125;else if(j&gt;0)&#123;</div><div class="line">				j=F[j-1];</div><div class="line">			&#125;else&#123;</div><div class="line">				F[i]=0;</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>####前缀表算法解析：<br><img src="http://img.blog.csdn.net/20170720113843819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170720113852250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>懵逼歇菜不可怕，下来跟上思路对上面的算法详细解析：<br>假设模式串P为 a b a b a c a。依据如下步骤构造前缀表F。初始时候，m=lenth[P]=7，F[0]=0。<br><img src="http://img.blog.csdn.net/20170720115544166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>1、i=1；j=0；P[1]！=P[0]，且j=0，则F[1]=0，i++；<br>解释：因为P[1]！=P[0]，在0-1这个子串上所以没有相等的前后缀，在1这个位置上构造表填0；<br><img src="http://img.blog.csdn.net/20170720121222563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>2、i=2；j=0；P[2]==P[0]，则F[2]=1，i++，j++；<br>解释：因为P[2]==P[0]，在0-2这个子串上出现了相等的前后缀，a==a，且最大长度为1，在2这个位置上构造表填1。<br><img src="http://img.blog.csdn.net/20170720121443387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>3、i=3；j=1；P[3]==P[1]，则F[3]=2，i++，j++；<br>解释：因为P[3]==P[1]，在0-3这个子串上出现了相等的前后缀，ab==ab，且最大长度为2，在3这个位置上构造表填2。<br><img src="http://img.blog.csdn.net/20170720121622826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>4、i=4；j=2；P[4]==P[2]，则F[4]=3，i++，j++；<br>在这儿停一下，先不急着往下看，思考一下，填的这个3是相等（重复）前后缀的长度，其实对前缀来说，它也是下标，是前缀末尾数字的下一个下标位置。这样，当我们去匹配i=5这个位置上的数时，如果没有匹配上，但是很显然在它前面的数P[0-4]肯定是匹配成功的，也就是说很显然它前面的前后缀肯定是匹配成功的，所以下一次我们就没必要回溯到j=0的位置，而是直接从前缀的下一个下标位置i=3开始即可。有没有懂一点？所以这儿就解释了为什么算法中F[i]=j+1。因为F[i]记录了相等前后缀的下一个下标位置哦，也即为相等前后缀的长度。<br><img src="http://img.blog.csdn.net/20170720121721469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>5、i=5；j=3；P[5]!=P[3]，且j&gt;0，则j=F[j-1]=1；<br>6、继续while，i=5；j=1；P[5]!=P[1]，且j&gt;0，则j=F[j-1]=0；<br>7、继续while，i=5；j=0；P[5]!=P[0]，且j！&gt;0，则F[i]=F[5]=0，i++；</p>
<p>咦，<font color="#ff0000" size="3px">为什么当P[i]!=P[j]时j=F[j-1]呢？</font> 这才是我们讨论的重点。见下面注：<br><img src="http://img.blog.csdn.net/20170720122438009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>8、i=6；j=0；P[6]==P[0]，则F[6]=1，i++，j++；<br><img src="http://img.blog.csdn.net/20170720122450152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>至此，前缀表构造完成。</p>
<p><font color="#ff0000" size="3px"><b>注：</b></font><br>看了多多少少不下10篇博客，没发现有一篇把else这块是彻彻底底讲清楚这个问题的，可见是多么的难以描述。晚上终于是把j=F[j-1]（有的地方为j=F[j]，原因是我们定义的前缀表初始值不同）搞懂了，历时1天，可见有多笨…………….<br>首先，必须明确这样一个结论：</p>
<p>当P[i] == P[j]时，<br>有<font color="#ff0000" size="3px">F[j+1] == F[j] + 1，F[j-1] == F[j] - 1</font><br>这个结论不多说，如下图紫色线条，稍微揣摩一下就能看得出来。<br><img src="http://img.blog.csdn.net/20170721105220168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><font color="#ff0000" size="3px">寻找前后缀的过程其实就是个匹配过程，理解成这样很重要，因为我们下面的内容都是基于这个思路分析的！</font> 在i=5和j=3的地方c!=b，匹配不成功。摒弃 i 这个概念，先不管 i。</p>
<p>暴力情况下，当匹配不成功时，我们的j应该回溯到0的位置，但是KMP的思想是如果存在最长前后缀，那我们就没必要再回溯到开头去，而是利用这个已经匹配过的最长前后缀。那我们致力于去寻找这个最长前后缀。在j=3时，j位置的最长前后缀即为F[j]，长度为2，F[j]=k+1，所以K=1。此时如果我们将j向左移动到j=k=1，再去和i=5匹配，是不是j没有回溯到开头，而是利用了匹配过的最长前后缀，仔细体会一下。如下图：<br><img src="http://img.blog.csdn.net/20170721105227572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>那这个时候的j=1用公式怎么求呢？</p>
<p>前面我们知道：<br>① F[j+1] == F[j] + 1<br>② F[j-1] == F[j] - 1<br>③ F[j]=k+1</p>
<p>由 ③ 可得 F[j]-1 = k，记为④。<br>由 ②+④ 可得k= F[j-1]。</p>
<p>所以F[j-1]应为我们的j往前移动的位置，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">else if(j&gt;0)&#123;</div><div class="line">				j=F[j-1];</div><div class="line">			&#125;</div></pre></td></tr></table></figure></p>
<p>终于是分析完这个else了，搞定了前缀表的构造，下来的匹配算法就简单多了，其实在上面我们已经把匹配算法的思想贯彻了。</p>
<hr>
<p>算法如下（java）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int KMP(String Ts,String Ps)&#123;</div><div class="line">	int i=0,j=0,m=0,n=0;</div><div class="line">	m=Ps.length();</div><div class="line">	n=Ts.length();</div><div class="line">	char[] T = Ts.toCharArray();</div><div class="line">	char[] P = Ps.toCharArray();</div><div class="line">	if(n&lt;m)&#123;return -1;&#125;</div><div class="line">	Prefix_Table(P,m);</div><div class="line">	while(i&lt;n &amp;&amp; j&lt;m)&#123;</div><div class="line">		if(j&lt;=0 || T[i]==P[j])&#123;</div><div class="line">				i++;</div><div class="line">				j++;</div><div class="line">		&#125;else&#123;</div><div class="line">			j=F[j-1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	if(j==m)&#123;</div><div class="line">		return i-j;</div><div class="line">	&#125;</div><div class="line">	return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io/" target="_blank" rel="external">https://qht1003077897.github.io/</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----KMP算法（摘自数据结构与算法经典问题解析 338 页问题 15.6）
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法-归并排序算法</title>
    <link href="http://yoursite.com/2017/07/12/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/12/算法-归并排序算法/</id>
    <published>2017-07-12T14:00:16.000Z</published>
    <updated>2017-07-17T09:20:07.491Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序算法是分治算法技术的一个实例。</p>
<p>插入排序、交换排序、和选择排序这三类排序算法都是讲无序的记录序列按关键字的带下排成一个有序序列。而归并排序则是将两个或者以上的有序序列合并成为一个有序序列的过程。将两个有序序列合并（归并）成一个有序序列称为二路归并。将N个有序序列合并（归并）成一个有序序列称为N路归并。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>时间复杂度：O(nlogn) </li>
<li>空间复杂度：O（n）<br>重要提示：</li>
</ul>
<hr>
<ul>
<li>归并是把两个已排序文件合并成一个更大的已排序文件的过程。</li>
<li>归并排序是快速排序的补充。</li>
<li>归并排序以连续的方式访问数据。</li>
<li>归并排序适用于链表排序。</li>
<li>归并排序对输入的初始次序不敏感。</li>
<li>快排是从最大子文件开始并以最小子文件结束，因此需要栈结构。归并排序是以最小子文件开始而以最大子文件结束，因此不需要栈。</li>
<li>归并算法是稳定的算法。</li>
</ul>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>归并排序分为两部分，拆分与合并。下面以二路归并为例：</p>
<ul>
<li><p>将长度为n的无序表对半分成两个无序子表，并对每一个无序子表继续进行对半拆分为两个子表的工作，直到每一个子表的长度为1，形成长度为1的有序子表（表长为1时为有序子表）。</p>
</li>
<li><p>开始第一趟二路归并，即将第1个表同第2个表归并，第3个表同第4个表归并·······若最后仅剩最后一个表，则不参加归并。这样得到的[n/2] 个长度为2（最后一个表的长度可能为1） 的有序表。</p>
</li>
<li><p>进行第二趟二路归并，即将第一趟得到的有序表继续进行两两归并，从而得到[n/4] 个长度为4（最后一个表的长度可能小于4） 的有序表。</p>
</li>
<li><p>以此类推，直到第[logn]趟归并完成，就得到了长度为n的有序表。</p>
</li>
</ul>
<p>对上面的过程我们可以总结为这样一种思想：</p>
<p><font color="#ff0000" size="4px">递归拆分，两两合并。<font></font></font></p>
<h2 id="算法实现（java）："><a href="#算法实现（java）：" class="headerlink" title="算法实现（java）："></a>算法实现（java）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">	/**</div><div class="line">	* 对两个数组合并</div><div class="line">	*/</div><div class="line">	public static void MergeArray(int[] A,int first,int last,int mid,int[] temp)&#123;</div><div class="line">		int k=0;</div><div class="line">		int i=first;</div><div class="line">		int j=mid+1;</div><div class="line">		while(i&lt;=mid &amp;&amp; j&lt;=last)&#123;</div><div class="line">			</div><div class="line">			if(A[i]&lt;=A[j])&#123;</div><div class="line">				temp[k++]=A[i++];</div><div class="line">			&#125;else&#123;</div><div class="line">				temp[k++]=A[j++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">			</div><div class="line">		while(i&lt;=mid)&#123;</div><div class="line">				temp[k++]=A[i++];</div><div class="line">			&#125;</div><div class="line">		while(j&lt;=last)&#123;</div><div class="line">				temp[k++]=A[j++];</div><div class="line">			&#125;</div><div class="line">		for(int l=0;l&lt;k;l++)&#123;</div><div class="line">			A[first+l]=temp[l];</div><div class="line">		&#125;	</div><div class="line">&#125;</div><div class="line">	</div><div class="line">	public static void MergeSort(int[] A,int first,int last,int[] temp)&#123;</div><div class="line">		int mid=(first+last)/2;</div><div class="line">		if(first&lt;last)&#123;</div><div class="line">			//递归对左右两边折半，最深一层左右各剩下一个元素</div><div class="line">			MergeSort(A, first, mid, temp);   </div><div class="line">			MergeSort(A, mid+1, last, temp);</div><div class="line">			MergeArray(A, first, last, mid, temp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		int[] A=new int[]&#123;1,4,2,8,5,9,477,25,1&#125;;</div><div class="line">		int[] temp=new int[A.length];</div><div class="line">		long time=System.nanoTime();</div><div class="line">		MergeSort(A, 0, A.length-1, temp);</div><div class="line">		System.out.println(&quot;MergeSort:&quot;+(System.nanoTime()-time));</div><div class="line">		for (int i : A) &#123;</div><div class="line">			System.out.println(i);	</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>打印内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">MergeSort:42863</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">4</div><div class="line">5</div><div class="line">8</div><div class="line">9</div><div class="line">25</div><div class="line">477</div></pre></td></tr></table></figure>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----归并排序算法（摘自数据结构与算法经典问题解析262页问题10.9 ）
    
    </summary>
    
      <category term="算法,面试" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法-快速排序算法</title>
    <link href="http://yoursite.com/2017/07/11/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/11/算法-快速排序算法/</id>
    <published>2017-07-11T14:00:16.000Z</published>
    <updated>2017-07-11T15:29:18.766Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序算法是分治算法技术的一个实例，也称为分区交换排序。快速排序采用递归调用对元素进行排序，是基于比较的排序算法中的一个著名算法，也是面试常考的一个算法。</p>
<p>本文主要思想借鉴于这篇文章：</p>
<blockquote>
<p>白话经典算法系列之六 快速排序 快速搞定<br><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">http://blog.csdn.net/morewindows/article/details/6684558</a></p>
</blockquote>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>时间复杂度：O(nlogn) </li>
<li>空间复杂度：O（1）<br>性能：</li>
</ul>
<hr>
<p>假设快速排序的复杂度为T(n) 且所有元素都不相同。T(n) 取决于两个子问题的规模，而规模又取决于中枢点。</p>
<ul>
<li>最好情况：每个划分把数组分成相等的两部分。时间复杂度为（nlogn）；</li>
<li>最坏情况：每个划分把数组分成不相等的两部分。时间复杂度为（n^2）,最坏情况发生在序列已经排序且选择最后一个元素作为中枢点。</li>
<li>平均情况下的时间复杂度与最好情况一样也为（nlogn）；</li>
</ul>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>书上说该算法主要由以下四步组成：</p>
<ol>
<li>如果数组中仅有一个元素或者没有元素需要排序，则返回。</li>
<li>选择数组中的一个元素作为中枢点（通常选择数组最左边的元素）。</li>
<li>把数组分成两部分，一部分元素大于中枢点，一部分元素小于中枢点。</li>
<li>对两部分数组递归调用该算法。</li>
</ol>
<p>借鉴参考文章，在这里我们巧妙的把它翻译为这样一种思想：</p>
<p><font color="#ff0000" size="4px">挖坑填数、分而治之。<font></font></font></p>
<h2 id="操作过程如下："><a href="#操作过程如下：" class="headerlink" title="操作过程如下："></a>操作过程如下：</h2><p>假设有如下数组，且拟定有一个数组 A[4,6,2,9,1,17] ，下标为index，和两个指针 left 和 right，和一个保存中枢点的变量 temp。</p>
<p>初始时，取第一个元素为中枢点，此时：left = 0;  right = 5;   temp = A[left] = 4;<br><img src="http://img.blog.csdn.net/20170711225641604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由于已经将A[0]中的数保存到temp中，可以理解成在数组A[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>1、首先从右向左，寻找第一个比temp小的数，准备填充到A[0]的位置上。<br>当right=4时满足情况，于是将A[4] 挖走，填充到上一个坑A[0]处，并且left++；此时：left=1；right=4；temp=4；形成新坑A[4]。<br><img src="http://img.blog.csdn.net/20170711230401427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>2、开始从左往右，寻找第一个比temp大的数，准备填充到A[4]的位置上。当left=1时，便满足条件，于是将A[1]挖走，填到上一个坑A[4]处，并且right–；此时：left=1；right=3；temp=4；形成新坑A[1];<br><img src="http://img.blog.csdn.net/20170711230835930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>3、开始从右往左，寻找第二个比temp小的数，准备填充到A[1]的位置上。<br>当right=2时满足情况，于是将A[2] 挖走，填充到上一个坑A[1]处，并且left++；此时：left=2；right=2；temp=4；形成新坑A[2]。<br><img src="http://img.blog.csdn.net/20170711231042553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>4、此时left=right，则第一趟排序结束，将temp填充到中枢点index=2的位置上，可以看到，4的左边都比4小，右边都比4大。<br><img src="http://img.blog.csdn.net/20170711231337105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>5、得到新的中枢点后，递归对左边和右边重复上述过程即可完成整个排序。</p>
<h2 id="对挖坑填数进行总结（引用自上述参考文章）："><a href="#对挖坑填数进行总结（引用自上述参考文章）：" class="headerlink" title="对挖坑填数进行总结（引用自上述参考文章）："></a>对挖坑填数进行总结（引用自上述参考文章）：</h2><blockquote>
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。<br>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
</blockquote>
<h2 id="算法实现（java）："><a href="#算法实现（java）：" class="headerlink" title="算法实现（java）："></a>算法实现（java）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static void sort(int[] A,int l,int r)&#123;</div><div class="line">	int left=l;</div><div class="line">	int right=r;</div><div class="line">	// index为下标，temp用来保存中枢位置的值，无关数组A,只是一个临时变量而已</div><div class="line">	int index,temp;</div><div class="line">	</div><div class="line">	if(A.length==0 || A.length==1)&#123;return;&#125;</div><div class="line">	if(left&gt;right)&#123;return;&#125;</div><div class="line">	//选取中枢，通常选择最左边的元素</div><div class="line">	temp=A[left];	</div><div class="line">	while(left &lt; right)&#123;</div><div class="line">	//先从右向左找不大于temp的元素</div><div class="line">	 while(left &lt; right &amp;&amp; A[right] &gt; temp)&#123;  </div><div class="line">		 right--;</div><div class="line">	 &#125;	</div><div class="line">	 if(left &lt; right)&#123;</div><div class="line">		//挖right，填left</div><div class="line">		A[left]=A[right];  </div><div class="line">		//填完之后，left右移一位        </div><div class="line">		left++;                   </div><div class="line">	 &#125;</div><div class="line">	 //再从左向右找不小于temp的元素来填上一个坑</div><div class="line">	 while(left &lt; right &amp;&amp; A[left] &lt;= temp)&#123;  </div><div class="line">		 left++;</div><div class="line">	 &#125;</div><div class="line">	 if(left &lt; right)&#123;</div><div class="line">		 //挖left，填上一次的right</div><div class="line">		 A[right]=A[left];   </div><div class="line">		 //填完之后，right左移一位        </div><div class="line">		 right--;					</div><div class="line">	 &#125;</div><div class="line">	&#125;</div><div class="line">	//走到这一步，必然left==right，得到中枢位置，将temp插入中枢位置</div><div class="line">	A[left]=temp; 	</div><div class="line">	//下标index						</div><div class="line">	index=left;					</div><div class="line">	//执行完一次排序操作，再对左边和右边分别递归</div><div class="line">	sort(A,l,index-1);</div><div class="line">	sort(A,index+1,r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void  main(String[] arg)&#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		int[] A=new int[]&#123;1,4,2,8,5,9,477,25,1&#125;;</div><div class="line">		</div><div class="line">		long time=System.nanoTime();</div><div class="line">		sort(A, 0, A.length-1);</div><div class="line">		System.out.println(&quot;耗时：&quot;System.nanoTime()-time);</div><div class="line">		for (int i : A) &#123;</div><div class="line">			System.out.println(i);	</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>打印内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">耗时：9659</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">4</div><div class="line">5</div><div class="line">8</div><div class="line">9</div><div class="line">25</div><div class="line">477</div></pre></td></tr></table></figure>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----快速排序算法（摘自数据结构与算法经典问题解析264页问题10.11 ）
    
    </summary>
    
      <category term="算法,面试" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法-堆排序算法</title>
    <link href="http://yoursite.com/2017/07/06/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/06/算法-堆排序算法/</id>
    <published>2017-07-06T14:00:16.000Z</published>
    <updated>2017-07-06T17:54:58.529Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序是利用堆的性质进行的一种选择排序。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><ul>
<li>时间复杂度：O(nlogn) </li>
<li>空间复杂度：O（1）（就地排序，用于堆化（又称筛选）的辅助空间）</li>
</ul>
<h2 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h2><ol>
<li><p>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的。</p>
</li>
<li><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成。</p>
</li>
<li><p>堆排序是一种不稳定排序。<br>科普：（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前和排序后他们的相对位置不发生变化）。</p>
</li>
<li><p>即使在最坏情况堆排序的时间复杂仍然为O(nlogn)。而快速排序在最坏情况下会达到O(N^2)，所以快排在最好和平均情况下比堆排快,堆排在最坏情况下比快排快。</p>
</li>
</ol>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p> 利用大（小）顶堆堆顶记录的是最大（小）关键字这一特性，使得每次从无序中选择最大（小）记录变得简单。<br> 下面的讨论全部基于大顶堆（小顶堆同理，不再赘述）。</p>
<ol>
<li><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n];</p>
</li>
<li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆（堆化、筛选），然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1（原堆剩最后一个元素），则整个排序过程完成。</p>
</li>
</ol>
<h2 id="操作过程如下："><a href="#操作过程如下：" class="headerlink" title="操作过程如下："></a>操作过程如下：</h2><ol>
<li>初始化堆：将R[1..n]构造为堆；</li>
<li>将当前无序区的堆顶元素R[1]同该区间的最后一个记录交换，然后将新的无序区调整为新的堆（不断堆化）。</li>
</ol>
<p>因此对于堆排序，最重要的两个操作就是构造初始堆和调整堆，其实构造初始堆事实上也是调整堆的过程，只不过构造初始堆是对所有的非叶节点都进行调整。</p>
<p>给定一个整形数组a[]={16,7,3,20,17,8}，对其进行堆排序。<br>首先根据该数组元素构建一个完全二叉树，得到：</p>
<p><img src="http://img.blog.csdn.net/20170707005835056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后需要构造初始堆，则从<strong>最后一个非叶节点</strong>开始调整，调整过程如下：</p>
<h2 id="以下为构造初始堆："><a href="#以下为构造初始堆：" class="headerlink" title="以下为构造初始堆："></a>以下为构造初始堆：</h2><ol>
<li>8和3交换，满足；</li>
<li><p>20和7交换，导致20和16不满足；<br><img src="http://img.blog.csdn.net/20170707010545789?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707010615238?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>20和16交换，导致17和16不满足；</p>
</li>
<li><p>17和16交换；<br><img src="http://img.blog.csdn.net/20170707010630589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707010639863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>完成构建（大顶堆）。</p>
</li>
</ol>
<p>即每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换(交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整)。有了初始堆之后就可以进行排序了。</p>
<h2 id="以下为交换元素并每步堆化（排序）："><a href="#以下为交换元素并每步堆化（排序）：" class="headerlink" title="以下为交换元素并每步堆化（排序）："></a>以下为交换元素并每步堆化（排序）：</h2><ol>
<li><p>交换3与20；  如下图：<br>此时3位于堆顶不满大顶堆的性质，则需继续调整。<br>交换3与17，导致3与16不满足；<br>交换3与16；<br>满足；<br><img src="http://img.blog.csdn.net/20170707011227881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707011429996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707011922837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>交换17与3；如下图：<br>此时3位于堆顶不满大顶堆的性质，则需继续调整。<br>交换3与16，导致3与7不满足；<br>交换3与7；<br>满足；<br><img src="http://img.blog.csdn.net/20170707012016247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707012201512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707012208510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li>交换16与3；如下图：<br>此时3位于堆顶不满大顶堆的性质，则需继续调整。<br>交换3与8；<br>满足；<br><img src="http://img.blog.csdn.net/20170707012326099?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707012436414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li>交换3与8；如下图：<br>此时3位于堆顶不满大顶堆的性质，则需继续调整。<br>交换3与7；<br>满足；<br><img src="http://img.blog.csdn.net/20170707012548626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170707012627747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li>交换3与7；如下图：<br>满足，完成排序。<br><img src="http://img.blog.csdn.net/20170707013241010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ol>
<p>这样整个区间便已经有序了。<br>从上述过程可知，堆排序其实也是一种选择排序，是一种树形选择排序。只不过直接选择排序中，为了从R[1…n]中选择最大记录，需比较n-1次，然后从R[1…n-2]中选择最大记录需比较n-2次。事实上这n-2次比较中有很多已经在前面的n-1次比较中已经做过，而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。对于n个关键字序列，最坏情况下每个节点需比较logn次，因此其最坏情况下时间复杂度为nlogn。</p>
<h2 id="算法实现（java）："><a href="#算法实现（java）：" class="headerlink" title="算法实现（java）："></a>算法实现（java）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">	/**定义堆*/</div><div class="line">static	class Heap&#123;</div><div class="line">	int count;</div><div class="line">	public int[] Array;</div><div class="line">	public Heap(int count)&#123;</div><div class="line">		this.count=count;</div><div class="line">		this.Array=new int[count];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**获取左孩子的方法*/</div><div class="line">	public int getLeft(int i)&#123;</div><div class="line">		int left=2*i+1;</div><div class="line">		if(this.Array==null || left&gt;=this.count)&#123;return -1;&#125;</div><div class="line">		return left;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**获取右孩子的方法*/</div><div class="line">	public int getRight(int i)&#123;</div><div class="line">		int right=2*i+2;</div><div class="line">		if(this.Array==null || right&gt;=this.count)&#123;return -1;&#125;</div><div class="line">		return right;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**堆化（筛选）*/</div><div class="line">	public void PercolateDown(int i)&#123;</div><div class="line">		int left,right,max = 0,temp;</div><div class="line">		</div><div class="line">		left=this.getLeft(i);</div><div class="line">		right=this.getRight(i);</div><div class="line">		if(left!=-1 &amp;&amp; this.Array[i]&gt;=this.Array[left])&#123;</div><div class="line">			max=i;</div><div class="line">		&#125;else&#123;</div><div class="line">			max=left;	</div><div class="line">		&#125;</div><div class="line">		if(right!=-1 &amp;&amp;  this.Array[right]&gt;this.Array[max])&#123;</div><div class="line">			max=right;</div><div class="line">		&#125;</div><div class="line">		//交换,交换完之后结束方法，由外部调用</div><div class="line">		if(max!=-1 &amp;&amp; max!=i)&#123;</div><div class="line">			temp=Array[max]; </div><div class="line">			Array[max]=Array[i];</div><div class="line">			Array[i]=temp;</div><div class="line">			</div><div class="line">			PercolateDown(max);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;	 	</div><div class="line"></div><div class="line">public  static void Heapsort(int[] A,int n)&#123;</div><div class="line">	Heap heap=new Heap(n);</div><div class="line">	int temp;</div><div class="line">	for(int i=0;i&lt;n;i++)&#123;</div><div class="line">		heap.Array[i]=A[i];</div><div class="line">	&#125;</div><div class="line">	//从第一个非叶子节点开始堆化（筛选）</div><div class="line">	for(int i=(n-1)/2;i&gt;=0;i--)&#123;</div><div class="line">		heap.PercolateDown(i);</div><div class="line">	&#125;</div><div class="line">	//第一次堆化完成， 开始交换，最后一个数和第一个数交换一次</div><div class="line">	for(int i=n-1;i&gt;=0;i--)&#123; //heap.Array[0] 存储最大元素</div><div class="line">		temp=heap.Array[0];</div><div class="line">		heap.Array[0]=heap.Array[i];</div><div class="line">		heap.Array[i]=temp;</div><div class="line">		//使用count的目的是在getleft的时候避免再去判断已经交换过（排序过）的元素</div><div class="line">		heap.count--;</div><div class="line">		//对第一个数不满足则再次进行堆化</div><div class="line">		heap.PercolateDown(0);</div><div class="line">	&#125;</div><div class="line">	long time1=System.nanoTime();</div><div class="line">	for (int j : heap.Array) &#123;</div><div class="line">		System.out.println(j);</div><div class="line">	&#125;</div><div class="line">	System.out.println(System.nanoTime()-time1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void  main(String[] arg)&#123;</div><div class="line">		int[] A=new int[]&#123;5,14,78,2,14,53,45,1&#125;;</div><div class="line">		Heapsort(A, A.length);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>打印内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">5</div><div class="line">14</div><div class="line">14</div><div class="line">45</div><div class="line">53</div><div class="line">78</div><div class="line">337776</div></pre></td></tr></table></figure>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----堆排序算法（摘自数据结构与算法经典问题解析190页问题11  注：原书中有好几处错误，已勘误）
    
    </summary>
    
      <category term="算法,面试" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法-直方图中的最大矩形</title>
    <link href="http://yoursite.com/2017/07/04/%E7%AE%97%E6%B3%95-%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2017/07/04/算法-直方图中的最大矩形/</id>
    <published>2017-07-04T14:00:16.000Z</published>
    <updated>2017-07-04T12:48:14.362Z</updated>
    
    <content type="html"><![CDATA[<p>直方图中最大矩形（(Largest Rectangle in Histogram)）</p>
<p>问题：直方图是由排列在同一基线上的一系列矩形组成的多边形。为了简单起见，假设这些矩形的宽度相等但高度可能不同。例如，下图1给出了一个直方图，其中各个矩形的高度为3、2、5、6、1、4、4，宽度为标准1单位。当给定了一个保存所有矩形高度的数组时，如何找到其中最大的矩形。对于给定的例子，最大矩形如图2阴影部分所示：<br><img src="http://img.blog.csdn.net/20170704144023023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>时间复杂度：O（n） （高效率）</li>
<li>空间复杂度：O（n） （栈开销）</li>
</ul>
<p>这个问题有多种解法，包含枚举、动态规划、分治等等。<br>这儿我们采用一种巧妙的方法，使用堆栈，将复杂度降到最低。</p>
<p>算法思想：</p>
<p>1、新建一个空栈，将 A[1] 压入栈中，此时 A[1] 位于栈顶。</p>
<p>2、A[i] 与栈顶元素比较。如果A[i] 大，那么将其入栈。如果两者相等，跳过，继续下一个元素。</p>
<ul>
<li>如果A[i]小于当前栈顶元素，说明已经找到第一个位于栈顶右边的比它小的值（此时这个较小的元素还未入栈），在它的左边（在栈内就是它脚下的元素）即为第一个左边比它小的值。此时需要这样做：</li>
</ul>
<pre><code>- 以栈顶元素为最小高度计算最大矩形面积，并更新现在的最大面积，宽度为左边界到右边界。

- 弹出栈顶元素。

- 重复第2步。
</code></pre><p>3.扫描完后，一般情况下会剩下一个单调递增的堆栈，那么一个一个出栈计算面积就可以了。左边依旧还是栈顶下面那个值，右边这个时候就不存在了，最后一个栈状态的栈顶即为右边界。</p>
<hr>
<p><strong>就拿上面的输入为例：[3、2、5、6、1、4、4]</strong></p>
<p>首先：记左边界为字母L，右边界为字母R，图中红色框为最新最大面积。</p>
<p><img src="http://img.blog.csdn.net/20170704154100788?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、  堆栈[ ]，开始扫描i从0到6；</p>
<p> 2、  i=0，因为堆栈为空，把3入栈<strong>【此时堆栈为[0]】</strong></p>
<p> 3、  i=1，因为a[i] =2 &lt; a[top] = a[0] =3，所以这个时候0出栈，并且计算a[0]作为矩形最小高度的面积，因为堆栈已空，所以左边界L就是0，右边界R就是i−1=0；所以最大面积就是a[0]×(R−L+1)=3;<strong>【此时堆栈为[ ]】</strong>然后再把i=1入栈。<strong>【此时堆栈[1]】</strong>，如上图。</p>
<p><img src="http://img.blog.csdn.net/20170704172139176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 4、  i=2，因为a[i] =5 &gt; a[top] = a[1] =2，所以i=2入栈。<strong>【此时堆栈[1,2]】</strong> </p>
<p> 5、 i=3，因为a[i] =6 &gt; a[top] = a[2] =5，所以i=3入栈。<strong>【此时堆栈[1,2,3]】</strong></p>
<p> 6、 i=4，因为a[i] =1 &lt; a[top] = a[3] =6，所以3要出栈，并且计算a[3]=6作为矩形最小高度的面积，左边就是栈顶下一个值加1，L=2+1=3，右边R=i−1=3，所以最大面积就是a[3]×(R−L+1)=6 ;<strong>【此时堆栈[1,2]】</strong>。如上图。</p>
<p><img src="http://img.blog.csdn.net/20170704155632934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>  此时a[i] =1 &lt;  a[top] = a[2] =5，所以2也要出栈，并且计算a[2]=5作为矩形最小高度的面积，左边就是栈顶下一个值加1，L=1+1=2，右边R=i−1=3，<strong>所以最大面积就是a[2]×(R−L+1)=10 ;【此时堆栈[1]】</strong>。如上图 。</p>
<p><img src="http://img.blog.csdn.net/20170704164034869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>  再此时a[i] =1 &lt;  a[top] = a[1] =2，所以1也要出栈，并且计算a[1]=2作为矩形最小高度的面积，因为栈已空，则左边界为0，右边界R=i−1=3，所以最大面积就是a[1]×(R−L+1)=8 ，小于10，取10 ; 最后i=4入栈。<strong>【此时堆栈[4]】</strong>。如上图。</p>
<p> 7、  i=5，因为a[i] =4 &gt; a[top] = a[4] =1，所以i=5入栈。<strong>【此时堆栈[4,5]】</strong> </p>
<p> 8、 i=6，因为a[i] =4 = a[top] = a[4] =1，跳过。<strong>【此时堆栈[4,5]】</strong></p>
<p> 9、 i=7，扫描完毕了，此时a[4]，a[5]，a[6]必然单调增。然后再一个个出栈。</p>
<p><img src="http://img.blog.csdn.net/20170704171910717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>10、top=5出栈，计算面积，L=4+1=5,右边没值，相当于右边还有一个a[i=7]=0的矩形，那么R=7−1=6，所以面积就是a[5]×(R−L+1)=8。<strong>【此时堆栈[4]】</strong>。如上图。</p>
<p><img src="http://img.blog.csdn.net/20170704171925040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>11、top=4出栈，计算面积，栈空，左边为0，右边没值，相当于右边还有一个a[i=7]=0的矩形，那么R=7−1=6，所以面积就是a[4]×(R−L+1)=7。<strong>【此时堆栈[ ]】</strong>。如上图。</p>
<p> 12.计算完毕； </p>
<hr>
<p>算法如下（java）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public StackItem(int height, int index) &#123;</div><div class="line">			// TODO Auto-generated constructor stub</div><div class="line">			this.height=height;</div><div class="line">			this.index=index;</div><div class="line">		&#125;</div><div class="line">		public int height;</div><div class="line">		public int index;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public int MaxRecttangleArea(int A[],int n)&#123;</div><div class="line">		int maxRean=0;</div><div class="line">		if(null==A || A.length&lt;=0)&#123;</div><div class="line">			return maxRean;</div><div class="line">		&#125;</div><div class="line">		Stack&lt;StackItem&gt; S=new Stack&lt;StackItem&gt;();</div><div class="line">		//先往栈中压入一个起始元素，为了进入后面的while循环</div><div class="line">		S.push(new StackItem(Integer.MIN_VALUE,-1)); </div><div class="line">		//这儿循环A.length次，让元素全部出栈</div><div class="line">		for(int i=0;i&lt;n;i++)&#123;  </div><div class="line">			StackItem cur=new StackItem((i&lt;n?A[i]:Integer.MIN_VALUE),i);</div><div class="line">			//lastElement 为栈顶</div><div class="line">			if(cur.height&gt;S.lastElement().height)&#123; </div><div class="line">				S.push(cur);</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">			while(S.size()&gt;0)&#123;</div><div class="line">				StackItem prev=S.lastElement();</div><div class="line">				int area=(i-prev.index)*prev.height;</div><div class="line">				if(area&gt;maxRean)&#123;</div><div class="line">					maxRean=area;</div><div class="line">				&#125;</div><div class="line">				prev.height=cur.height;</div><div class="line">				if(prev.height&gt;S.get(S.size()-2).height)&#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				S.pop();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return maxRean;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们测试一下时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] arg)&#123;</div><div class="line">		int[] A=new int[]&#123;3,2,5,6,1,4,4&#125;;</div><div class="line">		MaxRectangleArea clazz=new MaxRectangleArea();</div><div class="line">		long time=System.nanoTime();</div><div class="line">		System.out.println(clazz.MaxRecttangleArea(A, 7)+&quot;&quot;);</div><div class="line">		 long estimatedTime = System.nanoTime() - time;</div><div class="line">		System.out.println(estimatedTime);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">1169687</div></pre></td></tr></table></figure>
<p>总耗时1ms。</p>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io/" target="_blank" rel="external">https://qht1003077897.github.io/</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----求直方图最大矩形（摘自数据结构与算法经典问题解析 95 页问题 24）
    
    </summary>
    
      <category term="算法,面试" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法-floyd判环(圈)算法</title>
    <link href="http://yoursite.com/2017/07/03/%E7%AE%97%E6%B3%95-floyd%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
    <id>http://yoursite.com/2017/07/03/算法-floyd判断链表是否有环/</id>
    <published>2017-07-03T14:00:16.000Z</published>
    <updated>2017-07-03T09:52:50.548Z</updated>
    
    <content type="html"><![CDATA[<p>floyd（Floyd cycle detection）</p>
<p>问题：如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？</p>
<ul>
<li>时间复杂度：O（n） （高效率）</li>
<li>空间复杂度：O（1）</li>
</ul>
<p>此算法又成为龟兔赛跑算法，基本思想是：</p>
<p>好比两个人在赛跑，A的速度快，B的速度慢，经过一定时间后，A总是会和B相遇，且相遇时A跑过的总距离减去B跑过的总距离一定是圈长的n倍（初中数学题……）。</p>
<p>弗洛伊德（Floyd ）使用了两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行。但是如果移动步数增加，算法的复杂度可能增加）。如果两者在链表头以外（不包含开始情况）的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾（如果存在结尾，肯定无环），那么说明没环。</p>
<p>环的检测从上面的解释理解起来应该没有问题。接下来我们来看一下如何确定环的起点，这也是Floyd解法的第二部分。方法是将慢指针（或快指针）移到链表起点，然后两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p>
<p>下面给出论证过程：</p>
<p>假设一个链表是下面这样的：</p>
<p><img src="http://img.blog.csdn.net/20170703170559457?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>设环长为n，非环形部分长度为m，当第一次相遇时显然slow指针行走了 m+A<em>n+k（A表示slow行走了A圈。附：A</em>n 是因为如果环够大，则他们的相遇需要经过好几环才相遇）。fast行走了 m+B*n+k。</p>
<p>上面我们说了slow每次行走一步，fast每次行走两步，则在同一时间，fast行走的路程是slow的两倍。假设slow行走的路程为S，则fast行走的路程为2S。</p>
<p>用fast减去slow可得：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">S=（B-A）*n</div></pre></td></tr></table></figure></p>
<p>很显然这意味着当slow和fast相遇时他们走过的路程都为圈长的倍数。</p>
<p>接下来，将slow移动到起点位置，如下图：</p>
<p><img src="http://img.blog.csdn.net/20170703172340818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后每次两个指针都只移动一步，当slow移动了m，即到达了环的起点位置，此时fast总共移动了 2S+m。 考虑到S为环长的倍数，可以理解为：fast先从链表起点出发，经过了m到达环的起点，然后绕着环移动了几圈，最终又到达环的起点，值为2S+m。所以fast最终必定处在环的起点位置。即两者相遇点即为环的起点位置。</p>
<hr>
<p>算法如下（Java）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public ListNode findBeginLoop(ListNode head)&#123;</div><div class="line"></div><div class="line">ListNode slowPtr=head;</div><div class="line">ListNode fastPtr=head;</div><div class="line">boolean loopExists=false;</div><div class="line"></div><div class="line">if(head=null)&#123;return 0;&#125;</div><div class="line"></div><div class="line">while(slowPtr.getNext()!=null &amp;&amp; fastPtr.getNext().getNext()!=nulll)&#123;</div><div class="line"> slowPtr=slowPtr.getNext();</div><div class="line"> fastPtr=fastPtr.getNext().getNext();</div><div class="line"> if(slowPtr==fastPtr)&#123;</div><div class="line">	loopExists=true;</div><div class="line">	break;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  if(loopExists)&#123;  //环存在</div><div class="line">    slowPtr=head;</div><div class="line">	while(slowPtr!=fastPtr)&#123;</div><div class="line">		slowPtr=slowPtr.getNext();</div><div class="line">		fastPtr=fastPtr.getNext();</div><div class="line">	&#125;</div><div class="line">	return slowPtr;</div><div class="line">  &#125; </div><div class="line">  return null; //环不存在</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要求环的长度，可以这样做：</p>
<p>当两者相遇之后，固定一个指针，让另一个指针行走一圈，使用count计数，如果两个指针相等（即相遇），则count即为环的长度。</p>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io/" target="_blank" rel="external">https://qht1003077897.github.io/</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      面试算法之----floyd判环算法（摘自数据结构与算法经典问题解析57页问题9）
    
    </summary>
    
      <category term="算法,面试" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>安卓面试清单----OKHttp源码解析（三）</title>
    <link href="http://yoursite.com/2017/06/19/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/06/19/OkHttp源码解析（三）/</id>
    <published>2017-06-19T00:54:16.000Z</published>
    <updated>2017-07-17T09:27:11.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sendRequest"><a href="#sendRequest" class="headerlink" title="sendRequest ()"></a>sendRequest ()</h2><p>上篇文章我们讲了sendRequest ()方法，这节接着来看readResponse方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">/**来自HttpEngine 类*/</div><div class="line"></div><div class="line"> public void readResponse() throws IOException &#123;</div><div class="line">      if(this.userResponse == null) &#123;</div><div class="line">         if(this.networkRequest == null &amp;&amp; this.cacheResponse == null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;call sendRequest() first!&quot;);</div><div class="line">         &#125; else if(this.networkRequest != null) &#123;</div><div class="line">            Response networkResponse;</div><div class="line">            if(this.forWebSocket) &#123;</div><div class="line">               this.httpStream.writeRequestHeaders(this.networkRequest);</div><div class="line">               networkResponse = this.readNetworkResponse();</div><div class="line">            &#125; else if(!this.callerWritesRequestBody) &#123;</div><div class="line">             // 先执行拦截器，再写入request到HttpStream的Sinkbuffer中，最后发送buffer，并读取response</div><div class="line">               networkResponse = (new HttpEngine.NetworkInterceptorChain(0, this.networkRequest)).proceed(this.networkRequest);</div><div class="line">            &#125; else &#123;</div><div class="line">               if(this.bufferedRequestBody != null &amp;&amp; this.bufferedRequestBody.buffer().size() &gt; 0L) &#123;</div><div class="line">               // 将request body的buffer发出去，这样requestBodyOut中就有了body</div><div class="line">                  this.bufferedRequestBody.emit();</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if(this.sentRequestMillis == -1L) &#123;</div><div class="line">                  if(OkHeaders.contentLength(this.networkRequest) == -1L &amp;&amp; this.requestBodyOut instanceof RetryableSink) &#123;</div><div class="line">                     long responseCache = ((RetryableSink)this.requestBodyOut).contentLength();</div><div class="line">                     this.networkRequest = this.networkRequest.newBuilder().header(&quot;Content-Length&quot;, Long.toString(responseCache)).build();</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  this.httpStream.writeRequestHeaders(this.networkRequest);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if(this.requestBodyOut != null) &#123;</div><div class="line">                  if(this.bufferedRequestBody != null) &#123;</div><div class="line">                     this.bufferedRequestBody.close();</div><div class="line">                  &#125; else &#123;</div><div class="line">                     this.requestBodyOut.close();</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  if(this.requestBodyOut instanceof RetryableSink) &#123;</div><div class="line">                // body 写入socket中   </div><div class="line">                                this.httpStream.writeRequestBody((RetryableSink)this.requestBodyOut);</div><div class="line">                  &#125;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               networkResponse = this.readNetworkResponse();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.receiveHeaders(networkResponse.headers());</div><div class="line">            if(this.cacheResponse != null) &#123;</div><div class="line">               if(validate(this.cacheResponse, networkResponse)) &#123;</div><div class="line">                  this.userResponse = this.cacheResponse.newBuilder().request(this.userRequest).priorResponse(stripBody(this.priorResponse)).headers(combine(this.cacheResponse.headers(), networkResponse.headers())).cacheResponse(stripBody(this.cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class="line">                  networkResponse.body().close();</div><div class="line">                  this.releaseStreamAllocation();</div><div class="line">                  InternalCache responseCache1 = Internal.instance.internalCache(this.client);</div><div class="line">                  responseCache1.trackConditionalCacheHit();</div><div class="line">                  responseCache1.update(this.cacheResponse, stripBody(this.userResponse));</div><div class="line">                  this.userResponse = this.unzip(this.userResponse);</div><div class="line">                  return;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               Util.closeQuietly(this.cacheResponse.body());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.userResponse = networkResponse.newBuilder().request(this.userRequest).priorResponse(stripBody(this.priorResponse)).cacheResponse(stripBody(this.cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class="line">            if(hasBody(this.userResponse)) &#123;</div><div class="line">               this.maybeCache();</div><div class="line">               this.userResponse = this.unzip(this.cacheWritingResponse(this.storeRequest, this.userResponse));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>定位到第8行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.httpStream.writeRequestHeaders(this.networkRequest);</div></pre></td></tr></table></figure></p>
<p>writeRequestHeaders这个方法是HttpStream 接口的方法，由Http1xStream和Http2xStream重写。</p>
<p>如果采用http1.x协议，则执行Http1xStream里面的writeRequestHeaders方法，如果为http2.0，则执行Http2xStream的。由上文我们知道这取决于请求是http还是https。我们以1x为类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**来自 Http1xStream 类*/</div><div class="line"></div><div class="line">public void writeRequestHeaders(Request request) throws IOException &#123;</div><div class="line">		this.httpEngine.writingRequestHeaders();</div><div class="line">		String requestLine = RequestLine.get(request, this.httpEngine</div><div class="line">				.getConnection().route().proxy().type());</div><div class="line">		this.writeRequest(request.headers(), requestLine);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>首先得到请求的RequestLine（StatusLine），这个值由方法名、URL，Http协议拼接而成。<br>其次执行writeRequest方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**来自 Http1xStream 类*/</div><div class="line"></div><div class="line">public void writeRequest(Headers headers, String requestLine)</div><div class="line">			throws IOException &#123;</div><div class="line">		if (this.state != 0) &#123;</div><div class="line">			throw new IllegalStateException(&quot;state: &quot; + this.state);</div><div class="line">		&#125; else &#123;</div><div class="line">			this.sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);</div><div class="line">			int i = 0;</div><div class="line"></div><div class="line">			for (int size = headers.size(); i &lt; size; ++i) &#123;</div><div class="line">				this.sink.writeUtf8(headers.name(i)).writeUtf8(&quot;: &quot;)</div><div class="line">						.writeUtf8(headers.value(i)).writeUtf8(&quot;\r\n&quot;);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			this.sink.writeUtf8(&quot;\r\n&quot;);</div><div class="line">			this.state = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>主要是将StatusLine和header信息写入sink，sink是什么呢，因为从上篇我们知道OKhttp底部是socket通信，所以sink就相当于我们在httpUrlConnection中使用的inputStream，它是socket的写入流，而source就是OutPutStream。</p>
<h2 id="readNetworkResponse"><a href="#readNetworkResponse" class="headerlink" title="readNetworkResponse()"></a>readNetworkResponse()</h2><p>再看第9行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**来自 HttpEngine 类*/</div><div class="line"></div><div class="line">private Response readNetworkResponse() throws IOException &#123;</div><div class="line">	 //对sink流执行flush操作</div><div class="line">      this.httpStream.finishRequest();</div><div class="line">      //等待服务器相应并读取服务器返回信息组装成我们需要的response</div><div class="line">      Response networkResponse = this.httpStream.readResponseHeaders().request(this.networkRequest).handshake(this.streamAllocation.connection().handshake()).header(OkHeaders.SENT_MILLIS, Long.toString(this.sentRequestMillis)).header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis())).build();</div><div class="line">      if(!this.forWebSocket) &#123;</div><div class="line">         networkResponse = networkResponse.newBuilder().body(this.httpStream.openResponseBody(networkResponse)).build();</div><div class="line">      &#125;</div><div class="line">      if(&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) &#123;</div><div class="line">         this.streamAllocation.noNewStreams();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return networkResponse;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>看下这个方法第7行是怎么组装的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**来自Http1xStream 类（下面是两个方法）*/</div><div class="line"></div><div class="line">public Builder readResponseHeaders() throws IOException &#123;</div><div class="line">		return this.readResponse();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Builder readResponse() throws IOException &#123;</div><div class="line">		if (this.state != 1 &amp;&amp; this.state != 3) &#123;</div><div class="line">			throw new IllegalStateException(&quot;state: &quot; + this.state);</div><div class="line">		&#125; else &#123;</div><div class="line">			try &#123;</div><div class="line">				StatusLine e;</div><div class="line">				Builder exception1;</div><div class="line">				 // 如果返回code不是100， 则直接将Response对象返回</div><div class="line">        // 对于100，continue，server还会继续返回response string，我们需要在while循环中继续接收并解析</div><div class="line">				do &#123;</div><div class="line">					e = StatusLine.parse(this.source.readUtf8LineStrict());</div><div class="line">					 // 从输入流里读出答复并组装成答复消息，放入构造的Response的工厂类Build中</div><div class="line">					exception1 = (new Builder()).protocol(e.protocol)</div><div class="line">							.code(e.code).message(e.message)</div><div class="line">							//答复头部的读取</div><div class="line">							.headers(this.readHeaders());</div><div class="line">				&#125; while (e.code == 100);</div><div class="line"></div><div class="line">				this.state = 4;</div><div class="line">				return exception1;</div><div class="line">			&#125; catch (EOFException arg2) &#123;</div><div class="line">				IOException exception = new IOException(</div><div class="line">						&quot;unexpected end of stream on &quot; + this.streamAllocation);</div><div class="line">				exception.initCause(arg2);</div><div class="line">				throw exception;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面主要是对答复头部的信息进行整理，而readNetworkResponse方法的第13行主要是对服务返回的body进行组装整理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**来自Http1xStream 类（下面是两个方法）*/</div><div class="line"></div><div class="line">public ResponseBody openResponseBody(Response response) throws IOException &#123;</div><div class="line">		Source source = this.getTransferStream(response);</div><div class="line">		return new RealResponseBody(response.headers(), Okio.buffer(source));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private Source getTransferStream(Response response) throws IOException &#123;</div><div class="line">		if (!HttpEngine.hasBody(response)) &#123;</div><div class="line">			return this.newFixedLengthSource(0L);</div><div class="line">		&#125; else if (&quot;chunked&quot;.equalsIgnoreCase(response</div><div class="line">				.header(&quot;Transfer-Encoding&quot;))) &#123;</div><div class="line">			return this.newChunkedSource(this.httpEngine);</div><div class="line">		&#125; else &#123;</div><div class="line">			long contentLength = OkHeaders.contentLength(response);</div><div class="line">			return contentLength != -1L ? this</div><div class="line">					.newFixedLengthSource(contentLength) : this</div><div class="line">					.newUnknownLengthSource();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.newChunkedSource(this.httpEngine);</div></pre></td></tr></table></figure>
<p>这句代码最后执行到ChunkedSource （实现source接口）的 read方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public long read(Buffer sink, long byteCount) throws IOException &#123;</div><div class="line">		if (byteCount &lt; 0L) &#123;</div><div class="line">			throw new IllegalArgumentException(&quot;byteCount &lt; 0: &quot;</div><div class="line">					+ byteCount);</div><div class="line">		&#125; else if (this.closed) &#123;</div><div class="line">			throw new IllegalStateException(&quot;closed&quot;);</div><div class="line">		&#125; else if (!this.hasMoreChunks) &#123;</div><div class="line">			return -1L;</div><div class="line">		&#125; else &#123;</div><div class="line">			if (this.bytesRemainingInChunk == 0L</div><div class="line">					|| this.bytesRemainingInChunk == -1L) &#123;</div><div class="line">				this.readChunkSize();</div><div class="line">				if (!this.hasMoreChunks) &#123;</div><div class="line">					return -1L;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			long read = Http1xStream.this.source.read(sink,</div><div class="line">					Math.min(byteCount, this.bytesRemainingInChunk));</div><div class="line">			if (read == -1L) &#123;</div><div class="line">				this.endOfInput(false);</div><div class="line">				throw new ProtocolException(&quot;unexpected end of stream&quot;);</div><div class="line">			&#125; else &#123;</div><div class="line">				this.bytesRemainingInChunk -= read;</div><div class="line">				return read;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面我们已经分析了Source是我们从服务读取的输入流，类似于OutPutStream，read方法则是从服务读取。</p>
<p>最终，回到readResponse方法的第9行，我们得到了完整的networkResponse。</p>
<p>我们再来看看validate(cacheResponse, networkResponse)方法是如何判断缓存是否可用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**来自HttpEngine 类的ReadResponse方法*/</div><div class="line"></div><div class="line">  private static boolean validate(Response cached, Response network) &#123;</div><div class="line">    //如果服务器返回304则缓存有效</div><div class="line">      if(network.code() == 304) &#123;</div><div class="line">         return true;</div><div class="line">      &#125; else &#123;</div><div class="line">         Date lastModified = cached.headers().getDate(&quot;Last-Modified&quot;);</div><div class="line">            //通过缓存和网络请求响应中的Last-Modified来计算是否是最新数据，如果是则缓存有效</div><div class="line">         if(lastModified != null) &#123;</div><div class="line">            Date networkLastModified = network.headers().getDate(&quot;Last-Modified&quot;);</div><div class="line">            if(networkLastModified != null &amp;&amp; networkLastModified.getTime() &lt; lastModified.getTime()) &#123;</div><div class="line">               return true;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>cache response存在的情况下，应该是缓存过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送条件get请求来验证cache的内容是否有变更即可，如果缓存是有效的，则返回304 Not Modifiled，且response中不会包含body，否则cache改变，回复200, OK。response中包含body。条件get请求有两种方式一种是Last-Modified-Date，一种是 ETag。这里采用了Last-Modified-Date，通过缓存和网络请求响应中的Last-Modified来计算是否是最新数据，如果是则缓存有效。</p>
<p>回到第一篇文章查找两个个参数 forWebSocket 和 callerWritesRequestBody，可以发现，这两个参数都为false，那么就是说<br>在readResponse方法中默认是不会执行第8、9行的，而是会去执行第11行，我们分析过发送请求时使用的拦截器模式，这里对答复的操作也用了同样的方式，不同于请求调用的是intercept，这里用的是proceed。所以我们有必要再分析以下这个拦截器，<br>重点是 proceed方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**来自HttpEngine 的内部类 NetworkInterceptorChain 实现了Chain接口*/</div><div class="line"></div><div class="line">  public Response proceed(Request request) throws IOException &#123;</div><div class="line">         ++this.calls;</div><div class="line">         if(this.index &gt; 0) &#123;</div><div class="line">            Interceptor response = (Interceptor)HttpEngine.this.client.networkInterceptors().get(this.index - 1);</div><div class="line">            Address code = this.connection().route().address();</div><div class="line">            if(!request.url().host().equals(code.url().host()) || request.url().port() != code.url().port()) &#123;</div><div class="line">               throw new IllegalStateException(&quot;network interceptor &quot; + response + &quot; must retain the same host and port&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(this.calls &gt; 1) &#123;</div><div class="line">               throw new IllegalStateException(&quot;network interceptor &quot; + response + &quot; must call proceed() exactly once&quot;);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">         if(this.index &lt; HttpEngine.this.client.networkInterceptors().size()) &#123;</div><div class="line">         //根据拦截器的数目取出拦截器并执行intercept里面用户自定义的处理方式，和我们之前分析过的一样</div><div class="line">         //</div><div class="line">            HttpEngine.NetworkInterceptorChain arg6 = HttpEngine.this.new NetworkInterceptorChain(this.index + 1, request);</div><div class="line">            Interceptor arg9 = (Interceptor)HttpEngine.this.client.networkInterceptors().get(this.index);</div><div class="line">            Response interceptedResponse = arg9.intercept(arg6);</div><div class="line">            if(arg6.calls != 1) &#123;</div><div class="line">               throw new IllegalStateException(&quot;network interceptor &quot; + arg9 + &quot; must call proceed() exactly once&quot;);</div><div class="line">            &#125; else if(interceptedResponse == null) &#123;</div><div class="line">               throw new NullPointerException(&quot;network interceptor &quot; + arg9 + &quot; returned null&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">               return interceptedResponse;</div><div class="line">            &#125;</div><div class="line">         &#125; else &#123;</div><div class="line">             //写入请求头部</div><div class="line">             HttpEngine.this.httpStream.writeRequestHeaders(request);</div><div class="line">            HttpEngine.this.networkRequest = request;</div><div class="line">			 //写入一些请求体</div><div class="line">               Sink arg4 = HttpEngine.this.httpStream.createRequestBody(request, request.body().contentLength());</div><div class="line">               BufferedSink arg7 = Okio.buffer(arg4);</div><div class="line">               request.body().writeTo(arg7);</div><div class="line">               arg7.close();</div><div class="line">            &#125;</div><div class="line">			//将之前写入的数据flush给socket并读取服务器答复</div><div class="line">            Response arg5 = HttpEngine.this.readNetworkResponse();</div><div class="line">            int arg8 = arg5.code();</div><div class="line">            if((arg8 == 204 || arg8 == 205) &amp;&amp; arg5.body().contentLength() &gt; 0L) &#123;</div><div class="line">               throw new ProtocolException(&quot;HTTP &quot; + arg8 + &quot; had non-zero Content-Length: &quot; + arg5.body().contentLength());</div><div class="line">            &#125; else &#123;</div><div class="line">               return arg5;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>里面的writeRequestHeader方法和 readNetworkResponse 方法我们已经分析过了。再经过这么多7788的跳转、嵌套，终于拿到了我们需要的Response。最后回到我们第一篇文章最初的getResponse 方法，找到这两句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Response arg22 = this.engine.getResponse();</div><div class="line">Request arg23 = this.engine.followUpRequest();</div></pre></td></tr></table></figure>
<p>第一句很明显是得到我们的response，直接返回userResponse。<br>第二句是对请求结果发生重定向时的处理，client发送一个request之后，server可能回复一个重定向的response，并在这个response中告知client需要重新访问的server的IP。此时，client需要重新向新的server发送request，并等待新server的回复。所以我们需要单独判断重定向response，并发送多次request。有了OKHttp，这一切你都不用管，它会自动帮你完成所有这一切。OKHttp中followUpRequest()方法就是完成这个功能的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OKHttp底层源码还是相当复杂的，毕竟它的功能如此之强大。OKHttp默认采用了Keep-Alive持久连接技术（并不代表一定长连接，取决于服务器），可支持gzip编码的response。在cache的处理上，如果cache可用，则直接使用cache，否则使用网络数据。OKHttp会做cache过期的判断和过期后的再验证。有了OKHttp，这一切你都不用管，它帮你cover掉了！</p>
<p>当需要做用户验证和重定向时，我们一般需要发送认证request，或向新server发送request，也就是要重新再生成新request并发送出去。有了OKHttp，这一切你都不用管，它又帮你cover掉了！</p>
<h2 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h2><p>1、研读几遍更新其中的错误和不足的点。<br>2、完善流程图，做到全面理解。</p>
]]></content>
    
    <summary type="html">
    
      OKHttp源码从头解析，面试杀手锏
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="OKHttp" scheme="http://yoursite.com/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>安卓面试清单----OKHttp源码解析（二）</title>
    <link href="http://yoursite.com/2017/06/16/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/06/16/OkHttp源码分析（二）/</id>
    <published>2017-06-16T00:54:16.000Z</published>
    <updated>2017-07-17T09:27:28.969Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们讲到了getResponse()方法，这节接着来看：</p>
<p>getResponse()方法中最重要的有两个方法，sendRequest() 和 readResponse()；</p>
<p>先来看 sendRequest() ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自 HttpEngine 类*/</div><div class="line"></div><div class="line">public void sendRequest() throws RequestException, RouteException, IOException &#123;</div><div class="line">      if(this.cacheStrategy == null) &#123;</div><div class="line">         if(this.httpStream != null) &#123;</div><div class="line">            throw new IllegalStateException();</div><div class="line">         &#125; else &#123;</div><div class="line">            Request request = this.networkRequest(this.userRequest);</div><div class="line">            InternalCache responseCache = Internal.instance.internalCache(this.client);</div><div class="line">            Response cacheCandidate = responseCache != null?responseCache.get(request):null;</div><div class="line">            long now = System.currentTimeMillis();</div><div class="line">            this.cacheStrategy = (new Factory(now, request, cacheCandidate)).get();</div><div class="line">            this.networkRequest = this.cacheStrategy.networkRequest;</div><div class="line">            this.cacheResponse = this.cacheStrategy.cacheResponse;</div><div class="line">            if(responseCache != null) &#123;</div><div class="line">               responseCache.trackResponse(this.cacheStrategy);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(cacheCandidate != null &amp;&amp; this.cacheResponse == null) &#123;</div><div class="line">               Util.closeQuietly(cacheCandidate.body());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(this.networkRequest == null &amp;&amp; this.cacheResponse == null) &#123;</div><div class="line">               this.userResponse = (new Builder()).request(this.userRequest).priorResponse(stripBody(this.priorResponse)).protocol(Protocol.HTTP_1_1).code(504).message(&quot;Unsatisfiable Request (only-if-cached)&quot;).body(EMPTY_BODY).build();</div><div class="line">            &#125; else if(this.networkRequest == null) &#123;</div><div class="line">               this.userResponse = this.cacheResponse.newBuilder().request(this.userRequest).priorResponse(stripBody(this.priorResponse)).cacheResponse(stripBody(this.cacheResponse)).build();</div><div class="line">               this.userResponse = this.unzip(this.userResponse);</div><div class="line">            &#125; else &#123;</div><div class="line">               boolean success = false;</div><div class="line"></div><div class="line">               try &#123;</div><div class="line">                  this.httpStream = this.connect();</div><div class="line">                  this.httpStream.setHttpEngine(this);</div><div class="line">                  if(this.writeRequestHeadersEagerly()) &#123;</div><div class="line">                     long contentLength = OkHeaders.contentLength(request);</div><div class="line">                     if(this.bufferRequestBody) &#123;</div><div class="line">                        if(contentLength &gt; 2147483647L) &#123;</div><div class="line">                           throw new IllegalStateException(&quot;Use setFixedLengthStreamingMode() or setChunkedStreamingMode() for requests larger than 2 GiB.&quot;);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        if(contentLength != -1L) &#123;</div><div class="line">                           this.httpStream.writeRequestHeaders(this.networkRequest);</div><div class="line">                           this.requestBodyOut = new RetryableSink((int)contentLength);</div><div class="line">                        &#125; else &#123;</div><div class="line">                           this.requestBodyOut = new RetryableSink();</div><div class="line">                        &#125;</div><div class="line">                     &#125; else &#123;</div><div class="line">                        this.httpStream.writeRequestHeaders(this.networkRequest);</div><div class="line">                        this.requestBodyOut = this.httpStream.createRequestBody(this.networkRequest, contentLength);</div><div class="line">                     &#125;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  success = true;</div><div class="line">               &#125; finally &#123;</div><div class="line">                  if(!success &amp;&amp; cacheCandidate != null) &#123;</div><div class="line">                     Util.closeQuietly(cacheCandidate.body());</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>第10句：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InternalCache responseCache = Internal.instance.internalCache(this.client);</div></pre></td></tr></table></figure>
<p>Internal 是个抽象类， Internal.instance 对象最终在 OKhttpClient 的static 代码块中构造，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**来自 OKhttpClient 类*/</div><div class="line"></div><div class="line">     Internal.instance = new Internal() &#123;</div><div class="line">        ......</div><div class="line">         public InternalCache internalCache(OkHttpClient client) &#123;</div><div class="line">            return client.internalCache();</div><div class="line">         &#125;</div><div class="line">		......</div><div class="line">      &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**来自 OKhttpClient 类*/</div><div class="line"></div><div class="line">InternalCache internalCache() &#123;</div><div class="line">      return this.cache != null?this.cache.internalCache:this.internalCache;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们这里需要看下cache.internalCache的实现，这个位于Cache.Java里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 类*/</div><div class="line"></div><div class="line"> this.internalCache = new InternalCache() &#123;</div><div class="line">		  //根据请求得到响应</div><div class="line">         public Response get(Request request) throws IOException &#123;</div><div class="line">            return Cache.this.get(request);</div><div class="line">         &#125;</div><div class="line">		  //缓存响应</div><div class="line">         public CacheRequest put(Response response) throws IOException &#123;</div><div class="line">            return Cache.this.put(response);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public void remove(Request request) throws IOException &#123;</div><div class="line">            Cache.this.remove(request);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public void update(Response cached, Response network) throws IOException &#123;</div><div class="line">            Cache.this.update(cached, network);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public void trackConditionalCacheHit() &#123;</div><div class="line">            Cache.this.trackConditionalCacheHit();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public void trackResponse(CacheStrategy cacheStrategy) &#123;</div><div class="line">            Cache.this.trackResponse(cacheStrategy);</div><div class="line">         &#125;</div><div class="line">      &#125;;</div></pre></td></tr></table></figure>
<p>就是一些对cache的控制，sendRequest方法中的responseCache就是Cache中的InternalCache，因此我们继续看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** getResponse 方法*/</div><div class="line"></div><div class="line"> Response cacheCandidate = responseCache != null</div><div class="line">        ? responseCache.get(request)</div><div class="line">        : null;</div></pre></td></tr></table></figure>
<p>在看get方法之前我们有必要看一下缓存响应的put方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 类*/</div><div class="line"></div><div class="line"></div><div class="line">private CacheRequest put(Response response) &#123;</div><div class="line">    //得到请求的方法</div><div class="line">    String requestMethod = response.request().method();</div><div class="line"></div><div class="line">    if (HttpMethod.invalidatesCache(response.request().method())) &#123;</div><div class="line">      try &#123;</div><div class="line">        remove(response.request());</div><div class="line">      &#125; catch (IOException ignored) &#123;</div><div class="line">        // The cache cannot be written.</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    //不缓存非GET方法的响应</div><div class="line">    if (!requestMethod.equals(&quot;GET&quot;)) &#123;</div><div class="line">      // Don&apos;t cache non-GET responses. We&apos;re technically allowed to cache</div><div class="line">      // HEAD requests and some POST requests, but the complexity of doing</div><div class="line">      // so is high and the benefit is low.</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (HttpHeaders.hasVaryAll(response)) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //使用JakeWharton大神的DiskLruCache进行缓存  采用LUR算法</div><div class="line">    Entry entry = new Entry(response);</div><div class="line">    DiskLruCache.Editor editor = null;</div><div class="line">    try &#123;</div><div class="line">      editor = cache.edit(urlToKey(response.request()));</div><div class="line">      if (editor == null) &#123;</div><div class="line">        return null;</div><div class="line">      &#125;</div><div class="line">      entry.writeTo(editor);</div><div class="line">      return new CacheRequestImpl(editor);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      abortQuietly(editor);</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，首先是对请求的方法进行判断，概括起来就是一句话：只缓存请求方法为GET的响应。然后符合缓存的条件后，使用响应创建一个Entry对象，然后使用DiskLruCache写入缓存，最终返回一个CacheRequestImpl对象。cache是DiskLruCache的实例，调用edit方法传入响应的key值，而key值就是对请求调用urlToKey方法。下面是urlToKey的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 类*/</div><div class="line"></div><div class="line">private static String urlToKey(Request request) &#123;</div><div class="line">    //MD5</div><div class="line">    return Util.md5Hex(request.url().toString());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>从代码就可以看出是对请求的URL做MD5然后再得到MD5值的十六进制表示形式，这儿就不继续看了。<br>Entry实例就是要写入的缓存部分，主要看一下它的writeTo()方法，该方法执行具体的写入磁盘操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 的static内部类 Entry*/</div><div class="line"></div><div class="line">public void writeTo(Editor editor) throws IOException &#123;</div><div class="line">         BufferedSink sink = Okio.buffer(editor.newSink(0));</div><div class="line">         sink.writeUtf8(this.url);</div><div class="line">         sink.writeByte(10);</div><div class="line">         sink.writeUtf8(this.requestMethod);</div><div class="line">         sink.writeByte(10);</div><div class="line">         sink.writeDecimalLong((long)this.varyHeaders.size());</div><div class="line">         sink.writeByte(10);</div><div class="line">         int i = 0;</div><div class="line"></div><div class="line">         int size;</div><div class="line">         for(size = this.varyHeaders.size(); i &lt; size; ++i) &#123;</div><div class="line">            sink.writeUtf8(this.varyHeaders.name(i));</div><div class="line">            sink.writeUtf8(&quot;: &quot;);</div><div class="line">            sink.writeUtf8(this.varyHeaders.value(i));</div><div class="line">            sink.writeByte(10);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         sink.writeUtf8((new StatusLine(this.protocol, this.code, this.message)).toString());</div><div class="line">         sink.writeByte(10);</div><div class="line">         sink.writeDecimalLong((long)this.responseHeaders.size());</div><div class="line">         sink.writeByte(10);</div><div class="line">         i = 0;</div><div class="line"></div><div class="line">         for(size = this.responseHeaders.size(); i &lt; size; ++i) &#123;</div><div class="line">            sink.writeUtf8(this.responseHeaders.name(i));</div><div class="line">            sink.writeUtf8(&quot;: &quot;);</div><div class="line">            sink.writeUtf8(this.responseHeaders.value(i));</div><div class="line">            sink.writeByte(10);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         if(this.isHttps()) &#123;</div><div class="line">            sink.writeByte(10);</div><div class="line">            sink.writeUtf8(this.handshake.cipherSuite().javaName());</div><div class="line">            sink.writeByte(10);</div><div class="line">            this.writeCertList(sink, this.handshake.peerCertificates());</div><div class="line">            this.writeCertList(sink, this.handshake.localCertificates());</div><div class="line">            if(this.handshake.tlsVersion() != null) &#123;</div><div class="line">               sink.writeUtf8(this.handshake.tlsVersion().javaName());</div><div class="line">               sink.writeByte(10);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         sink.close();</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看到，写入缓存的不仅仅只是响应的头部信息，还包括请求的部分信息：URL、请求方法、请求头部。至此，我们看到对于一个请求和响应，缓存中的key值是请求的URL的MD5值，而value包括请求和响应部分。Entry的writeTo()方法只把请求的头部和响应的头部保存了，最关键的响应主体部分在哪里保存呢？答案在put方法的返回体CacheRequestImpl，下面是这个类的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 的内部类 CacheRequestImpl，实现了CacheRequest接口*/</div><div class="line"></div><div class="line">    public CacheRequestImpl(final Editor editor) throws IOException &#123;</div><div class="line">         this.editor = editor;</div><div class="line">         this.cacheOut = editor.newSink(1);</div><div class="line">         this.body = new ForwardingSink(this.cacheOut) &#123;</div><div class="line">            public void close() throws IOException &#123;</div><div class="line">               Cache arg0 = Cache.this;</div><div class="line">               synchronized(Cache.this) &#123;</div><div class="line">                  if(CacheRequestImpl.this.done) &#123;</div><div class="line">                     return;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  CacheRequestImpl.this.done = true;</div><div class="line">                  Cache.this.writeSuccessCount++;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               super.close();</div><div class="line">               editor.commit();</div><div class="line">            &#125;</div><div class="line">         &#125;;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>最终，通过 editor.commit();进行缓存写入。看完了put方法再来看get方法就能好理解点了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 类*/</div><div class="line"></div><div class="line">  Response get(Request request) &#123;</div><div class="line">	</div><div class="line">      String key = urlToKey(request);</div><div class="line">      Snapshot snapshot;</div><div class="line">      try &#123;</div><div class="line">         snapshot = this.cache.get(key);</div><div class="line">         if(snapshot == null) &#123;</div><div class="line">            return null;</div><div class="line">         &#125;</div><div class="line">      &#125; catch (IOException arg6) &#123;</div><div class="line">         return null;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Cache.Entry entry;</div><div class="line">      try &#123;</div><div class="line">         entry = new Cache.Entry(snapshot.getSource(0));</div><div class="line">      &#125; catch (IOException arg5) &#123;</div><div class="line">         Util.closeQuietly(snapshot);</div><div class="line">         return null;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Response response = entry.response(snapshot);</div><div class="line">      if(!entry.matches(request, response)) &#123;</div><div class="line">         Util.closeQuietly(response.body());</div><div class="line">         return null;</div><div class="line">      &#125; else &#123;</div><div class="line">         return response;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，首先是对请求的URL进行MD5计算得到key值，然后尝试根据key值从缓存中得到值，如果没有该值，说明缓存中没有该值，那么直接返回null，否则创建Entry对象，然后再从Entry中得到响应对象，如果请求和响应不匹配(地址，请求方式、请求头) ，那么也返回null，否则就返回响应对象。<br>下面是Entry的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 类（Entry的构造方法）*/</div><div class="line"></div><div class="line">  public Entry(Source in) throws IOException &#123;</div><div class="line">         try &#123;</div><div class="line">            BufferedSource source = Okio.buffer(in);</div><div class="line">             //读请求相关信息</div><div class="line">            this.url = source.readUtf8LineStrict();</div><div class="line">            this.requestMethod = source.readUtf8LineStrict();</div><div class="line">            Builder varyHeadersBuilder = new Builder();</div><div class="line">            int varyRequestHeaderLineCount = Cache.readInt(source);</div><div class="line"></div><div class="line">            for(int statusLine = 0; statusLine &lt; varyRequestHeaderLineCount; ++statusLine) &#123;</div><div class="line">               varyHeadersBuilder.addLenient(source.readUtf8LineStrict());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.varyHeaders = varyHeadersBuilder.build();</div><div class="line">             //读响应状态行</div><div class="line">            StatusLine arg16 = StatusLine.parse(source.readUtf8LineStrict());</div><div class="line">            this.protocol = arg16.protocol;</div><div class="line">            this.code = arg16.code;</div><div class="line">            this.message = arg16.message;</div><div class="line">            //读响应首部</div><div class="line">            Builder responseHeadersBuilder = new Builder();</div><div class="line">            int responseHeaderLineCount = Cache.readInt(source);</div><div class="line"></div><div class="line">            for(int blank = 0; blank &lt; responseHeaderLineCount; ++blank) &#123;</div><div class="line">               responseHeadersBuilder.addLenient(source.readUtf8LineStrict());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.responseHeaders = responseHeadersBuilder.build();</div><div class="line">             //是HTTPS协议，读握手、证书信息</div><div class="line">            if(this.isHttps()) &#123;</div><div class="line">               String arg17 = source.readUtf8LineStrict();</div><div class="line">               if(arg17.length() &gt; 0) &#123;</div><div class="line">                  throw new IOException(&quot;expected \&quot;\&quot; but was \&quot;&quot; + arg17 + &quot;\&quot;&quot;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               String cipherSuiteString = source.readUtf8LineStrict();</div><div class="line">               CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);</div><div class="line">               List peerCertificates = this.readCertificateList(source);</div><div class="line">               List localCertificates = this.readCertificateList(source);</div><div class="line">               TlsVersion tlsVersion = !source.exhausted()?TlsVersion.forJavaName(source.readUtf8LineStrict()):null;</div><div class="line">               this.handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);</div><div class="line">            &#125; else &#123;</div><div class="line">               this.handshake = null;</div><div class="line">            &#125;</div><div class="line">         &#125; finally &#123;</div><div class="line">            in.close();</div><div class="line">         &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>在put方法中我们知道了缓存中保存了请求的信息和响应的信息。 获得了包含首部信息的Entry之后，再调用response方法得到正在的响应，下面是response()方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 内部类 Entry*/</div><div class="line"></div><div class="line">  public Response response(Snapshot snapshot) &#123;</div><div class="line">         String contentType = this.responseHeaders.get(&quot;Content-Type&quot;);</div><div class="line">         String contentLength = this.responseHeaders.get(&quot;Content-Length&quot;);</div><div class="line">         Request cacheRequest = (new okhttp3.Request.Builder()).</div><div class="line">         url(this.url).</div><div class="line">         method(this.requestMethod, (RequestBody)null).</div><div class="line">         headers(this.varyHeaders).build();</div><div class="line">         </div><div class="line">         return (new okhttp3.Response.Builder()). request(cacheRequest).</div><div class="line">         protocol(this.protocol).</div><div class="line">         code(this.code).</div><div class="line">         message(this.message).</div><div class="line">         headers(this.responseHeaders).</div><div class="line">         body(new Cache.CacheResponseBody(snapshot, contentType, contentLength)).</div><div class="line">         handshake(this.handshake).build();</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>再看下match方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 内部类 Entry*/</div><div class="line"></div><div class="line"> public boolean matches(Request request, Response response) &#123;</div><div class="line">         return this.url.equals(request.url().toString()) &amp;&amp; this.requestMethod.equals(request.method()) &amp;&amp; OkHeaders.varyMatches(response, this.varyHeaders, request);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>可以看到，响应的首部信息保存在Entry中，而主体部分是在传入的Snapshot中，主体是创建了一个CacheResponseBody对象。CacheResponseBody继承自ResponseBody类并且使用传入的Snapshot获得put中保存的响应主体部分。 </p>
<p>最终通过比较发起请求的url，方法，head等信息和缓存中的进行比较，决定是否返回response。</p>
<hr>
<p>OK，再回到 HttpEngine 类，上面分析完了10,11行，我们再来接着看13行，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.cacheStrategy = (new Factory(now, request, cacheCandidate)).get();</div></pre></td></tr></table></figure>
<p>可以看到根据当前时间、构建的Request请求体、和得到的缓存响应 创建一个工厂，然后再得到一个CacheStrategy。首先看该工厂的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 的内部static工厂类 Factory*/</div><div class="line"></div><div class="line">public Factory(long nowMillis, Request request, Response cacheResponse) &#123;</div><div class="line">			this.nowMillis = nowMillis;</div><div class="line">			this.request = request;</div><div class="line">			this.cacheResponse = cacheResponse;</div><div class="line">			if (cacheResponse != null) &#123;</div><div class="line">				Headers headers = cacheResponse.headers();</div><div class="line">				int i = 0;</div><div class="line"></div><div class="line">				for (int size = headers.size(); i &lt; size; ++i) &#123;</div><div class="line">					String fieldName = headers.name(i);</div><div class="line">					String value = headers.value(i);</div><div class="line">					if (&quot;Date&quot;.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.servedDate = HttpDate.parse(value);</div><div class="line">						this.servedDateString = value;</div><div class="line">					&#125; else if (&quot;Expires&quot;.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.expires = HttpDate.parse(value);</div><div class="line">					&#125; else if (&quot;Last-Modified&quot;.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.lastModified = HttpDate.parse(value);</div><div class="line">						this.lastModifiedString = value;</div><div class="line">					&#125; else if (&quot;ETag&quot;.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.etag = value;</div><div class="line">					&#125; else if (&quot;Age&quot;.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.ageSeconds = HeaderParser.parseSeconds(value, -1);</div><div class="line">					&#125; else if (OkHeaders.SENT_MILLIS</div><div class="line">							.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.sentRequestMillis = Long.parseLong(value);</div><div class="line">					&#125; else if (OkHeaders.RECEIVED_MILLIS</div><div class="line">							.equalsIgnoreCase(fieldName)) &#123;</div><div class="line">						this.receivedResponseMillis = Long.parseLong(value);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，如果候选的缓存响应不为null，那么将响应首部中有关缓存的首部的值得到，主要有Date、Expires、Last-Modified、ETag和Age首部。 </p>
<p>其中Date表明响应报文是何时创建的，Expires表示该响应的绝对过期时间，Last-Modified表示最近一次修改的时间。 </p>
<p>再看Factory的get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">	 *来自 Cache 的内部static工厂类 Factory</div><div class="line">     * Returns a strategy to satisfy &#123;@code request&#125; </div><div class="line">     * using the a cached response &#123;@code response&#125;.</div><div class="line">     */</div><div class="line">    public CacheStrategy get() &#123;</div><div class="line">      CacheStrategy candidate = getCandidate();</div><div class="line"></div><div class="line">return candidate.networkRequest != null</div><div class="line">						&amp;&amp; this.request.cacheControl().onlyIfCached() ?</div><div class="line">					 new CacheStrategy((Request) null, (Response) null) : candidate;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出首先调用getCandidate()得到候选的CacheStrategy对象，然后如果得到的缓存策略表明需要使用网络，但是请求中指定响应只能从缓存中得到，那么返回一个networkRequest和cacheResonse均为null的CacheStrategy。</p>
<p>OkHttp中使用了CacheStrategy，它根据之前的缓存结果与当前将要发送Request的header进行策略分析，并得出是否进行请求的结论。</p>
<p>CacheStrategy类似一个mapping操作，将两个值输入，再将两个值输出。</p>
<hr>
<pre><code>&gt; Input                request, cacheCandidate 
    ↓                        ↓
&gt; CacheStrategy     处理，判断Header信息
    ↓                         ↓  
&gt; Output        networkRequest, cacheResponse
</code></pre><hr>
<p>Request:<br>开发者手动编写并在Interceptor中递归加工而成的对象，我们只需要知道了目前传入的Request中并没有任何关于缓存的Header。</p>
<p>cacheCandidate:<br>也就是上次与服务器交互缓存的Response，可能为null。我们现在知道它是一个可以读取缓存Header的Response。</p>
<p>当被CacheStrategy加工输出后，输出networkRequest与cacheResponse，根据是否为空执行不同的请求。</p>
<p><img src="http://img.blog.csdn.net/20170616165105874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图 1 几种情况下的请求策略"></p>
<p>下面主要看一下getCandidate方法，该方法返回的策略是基于请求可以使用网络的假设之上的，所以这也就解释了get()方法中为什么要对使用网络但是请求却指定缓存响应的情况做区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">/**来自 Cache 的内部static工厂类 Factory*/</div><div class="line"></div><div class="line">private CacheStrategy getCandidate() &#123;</div><div class="line">			 //如果缓存没有命中(即null),网络请求也不需要加缓存Header了</div><div class="line">			if (this.cacheResponse == null) &#123;</div><div class="line">			 //`没有缓存的网络请求,查上文的表可知是直接访问</div><div class="line">				return new CacheStrategy(this.request, (Response) null);</div><div class="line">			&#125; </div><div class="line">			 // 如果缓存的TLS握手信息丢失,返回进行直接连接</div><div class="line">				else if (this.request.isHttps()</div><div class="line">					&amp;&amp; this.cacheResponse.handshake() == null) &#123;</div><div class="line">				return new CacheStrategy(this.request, (Response) null);</div><div class="line">			&#125; </div><div class="line">			 //检测response的状态码,Expired时间,是否有no-cache标签</div><div class="line">				else if (!CacheStrategy.isCacheable(this.cacheResponse,</div><div class="line">					this.request)) &#123;</div><div class="line">				return new CacheStrategy(this.request, (Response) null);</div><div class="line">			&#125; else &#123;</div><div class="line">				CacheControl requestCaching = this.request.cacheControl();</div><div class="line">				</div><div class="line">				if (!requestCaching.noCache() &amp;&amp; !hasConditions(this.request)) &#123;</div><div class="line">				    //根据RFC协议计算</div><div class="line">			        //计算当前age的时间戳</div><div class="line">			        //now - sent + age (s)</div><div class="line">					long ageMillis = this.cacheResponseAge();</div><div class="line">					//大部分情况服务器设置为max-age</div><div class="line">					long freshMillis = this.computeFreshnessLifetime();</div><div class="line">					if (requestCaching.maxAgeSeconds() != -1) &#123;</div><div class="line">					//大部分情况下是取max-age</div><div class="line">						freshMillis = Math.min(freshMillis,</div><div class="line">								TimeUnit.SECONDS.toMillis((long) requestCaching</div><div class="line">										.maxAgeSeconds()));</div><div class="line">					&#125;</div><div class="line">					long minFreshMillis = 0L;</div><div class="line">					if (requestCaching.minFreshSeconds() != -1) &#123;</div><div class="line">					//大部分情况下设置是0</div><div class="line">						minFreshMillis = TimeUnit.SECONDS</div><div class="line">								.toMillis((long) requestCaching</div><div class="line">										.minFreshSeconds());</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					long maxStaleMillis = 0L;</div><div class="line">					//ParseHeader中的缓存控制信息</div><div class="line">					CacheControl responseCaching = this.cacheResponse</div><div class="line">							.cacheControl();</div><div class="line">					if (!responseCaching.mustRevalidate()</div><div class="line">							&amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123;</div><div class="line">					//设置最大过期时间,一般设置为0</div><div class="line">						maxStaleMillis = TimeUnit.SECONDS</div><div class="line">								.toMillis((long) requestCaching</div><div class="line">										.maxStaleSeconds());</div><div class="line">					&#125;</div><div class="line">					//缓存在过期时间内,可以使用</div><div class="line">				    //大部分情况下是进行如下判断</div><div class="line">				    //now - sent + age + 0 &lt; max-age + 0</div><div class="line">					if (!responseCaching.noCache()</div><div class="line">							&amp;&amp; ageMillis + minFreshMillis &lt; freshMillis</div><div class="line">									+ maxStaleMillis) &#123;</div><div class="line">						Builder conditionalRequestBuilder1 = this.cacheResponse</div><div class="line">								.newBuilder();</div><div class="line">						if (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</div><div class="line">							conditionalRequestBuilder1</div><div class="line">									.addHeader(&quot;Warning&quot;,</div><div class="line">											&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;);</div><div class="line">						&#125;</div><div class="line"></div><div class="line">						long conditionalRequest1 = 86400000L;</div><div class="line">						if (ageMillis &gt; conditionalRequest1</div><div class="line">								&amp;&amp; this.isFreshnessLifetimeHeuristic()) &#123;</div><div class="line">							conditionalRequestBuilder1</div><div class="line">									.addHeader(&quot;Warning&quot;,</div><div class="line">											&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;);</div><div class="line">						&#125;</div><div class="line"></div><div class="line">						return new CacheStrategy((Request) null,</div><div class="line">								conditionalRequestBuilder1.build());</div><div class="line">					&#125; else &#123;</div><div class="line">						okhttp3.Request.Builder conditionalRequestBuilder = this.request</div><div class="line">								.newBuilder();</div><div class="line">						if (this.etag != null) &#123;</div><div class="line">							conditionalRequestBuilder.header(&quot;If-None-Match&quot;,</div><div class="line">									this.etag);</div><div class="line">						&#125; else if (this.lastModified != null) &#123;</div><div class="line">							conditionalRequestBuilder.header(</div><div class="line">									&quot;If-Modified-Since&quot;,</div><div class="line">									this.lastModifiedString);</div><div class="line">						&#125; else if (this.servedDate != null) &#123;</div><div class="line">							conditionalRequestBuilder.header(</div><div class="line">									&quot;If-Modified-Since&quot;, this.servedDateString);</div><div class="line">						&#125;</div><div class="line"></div><div class="line">						Request conditionalRequest = conditionalRequestBuilder</div><div class="line">								.build();</div><div class="line">						return hasConditions(conditionalRequest) ? new CacheStrategy(</div><div class="line">								conditionalRequest, this.cacheResponse)</div><div class="line">								: new CacheStrategy(conditionalRequest,</div><div class="line">										(Response) null);</div><div class="line">					&#125;</div><div class="line">				&#125; else &#123;</div><div class="line">				 //对应相应的iF请求</div><div class="line">				 //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)</div><div class="line">			     //或者有ETag/Since标签(也就是条件GET请求)</div><div class="line">					return new CacheStrategy(this.request, (Response) null);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上面的主要内容是缓存，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的。</li>
<li></li>
<li>Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。网上热传的文章在Interceptor中手工添加缓存代码控制，它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm、litepal）。</li>
<li></li>
<li>服务器的配置非常重要，如果你需要减小请求次数，建议直接找对接人员对max-age等头文件进行优化；服务器的时钟需要严格NTP同步。</li>
</ul>
<p>总结上面的方法：</p>
<ol>
<li><p>如果缓存没有命中，即cacheResponse==null，那么直接进行网络请求 </p>
</li>
<li><p>如果请求是HTTPS并且缓存响应中没有握手或者握手信息丢失，那么需要重新进行网络请求</p>
</li>
<li><p>如果响应不应该被存储，那么需要重新进行网络请求 （比如header中指定no-store）</p>
</li>
<li><p>如果请求中指定不使用缓存响应，那么需要进行网络请求 （比如header中指定no-cache）</p>
</li>
<li><p>接下来比较缓存响应检查是否有条件请求的首部，如果有，就进行额外的请求（ request.header(“If-Modified-Since”) != null || request.header(“If-None-Match”) != null）</p>
</li>
</ol>
<p>上面得到 CacheStrategy 后，我们下来再回到HttpEngine 定位到 17行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(responseCache != null) &#123;</div><div class="line">            responseCache.trackResponse(this.cacheStrategy);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**来自Cache类*/</div><div class="line"></div><div class="line"> private synchronized void trackResponse(CacheStrategy cacheStrategy) &#123;</div><div class="line">    requestCount++;</div><div class="line"></div><div class="line">    if (cacheStrategy.networkRequest != null) &#123;</div><div class="line">     // If this is a conditional request, we&apos;ll increment hitCount if/when it hits.</div><div class="line">      networkCount++;</div><div class="line">    &#125; else if (cacheStrategy.cacheResponse != null) &#123;</div><div class="line">     // This response uses the cache and not the network. That&apos;s a cache hit.</div><div class="line">      hitCount++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到该方法主要就是对Cache中的三个记录进行赋值，从这儿我们可以得出结论requestCount&gt;=networkCount+hitCount。</p>
<p>当networkRequest和cacheResponse均为null的时候，这个时候的响应既不是从网络得到也不是从缓存得到。 （查阅图1）</p>
<p>cacheResponse表示从缓存上得到的响应。如果该响应没有使用缓存，那么将会为null。</p>
<p>关于Response有一点需要铭记，该类的实例不是一成不变的，响应主体部分只能被消费一次然后关闭，其他参数是不变的。 </p>
<p>那么为什么Response的主体部分只能被消费一次呢？ </p>
<p>这是因为ResponseBody的底层是用Okio实现的，而Okio的Source只能被读取一次，因为读完之后，Buffer底层的Segment关于之前数据的信息（pos和limit）就丢失了，并且在读完一次之后就将Source关闭了，所以只能读一次。关于Okio的可以参考<a href="https://blog.piasy.com/2016/08/04/Understand-Okio/" target="_blank" rel="external">拆轮子系列：拆 Okio</a>。</p>
<hr>
<p>再用个分割线进行分割，上面的代码得到了缓存策略，即cacheStrategy，再次定位到HttpEngine 的第37行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.httpStream = this.connect();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**来自HttpEngine 类*/</div><div class="line"></div><div class="line">   private HttpStream connect() throws RouteException, RequestException, IOException &#123;</div><div class="line">      boolean doExtensiveHealthChecks = !this.networkRequest.method().equals(&quot;GET&quot;);</div><div class="line">      return this.streamAllocation.newStream(this.client.connectTimeoutMillis(), this.client.readTimeoutMillis(), this.client.writeTimeoutMillis(), this.client.retryOnConnectionFailure(), doExtensiveHealthChecks);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>跳转到 newStream 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**来自StreamAllocation 类*/</div><div class="line"></div><div class="line">public HttpStream newStream(int connectTimeout, int readTimeout,</div><div class="line">			int writeTimeout, boolean connectionRetryEnabled,</div><div class="line">			boolean doExtensiveHealthChecks) throws RouteException, IOException &#123;</div><div class="line">		try &#123;</div><div class="line">			RealConnection e = this.findHealthyConnection(connectTimeout,</div><div class="line">					readTimeout, writeTimeout, connectionRetryEnabled,</div><div class="line">					doExtensiveHealthChecks);</div><div class="line">			Object resultStream;</div><div class="line">			if (e.framedConnection != null) &#123;</div><div class="line">				resultStream = new Http2xStream(this, e.framedConnection);</div><div class="line">			&#125; else &#123;</div><div class="line">				e.socket().setSoTimeout(readTimeout);</div><div class="line">				e.source.timeout().timeout((long) readTimeout,</div><div class="line">						TimeUnit.MILLISECONDS);</div><div class="line">				e.sink.timeout().timeout((long) writeTimeout,</div><div class="line">						TimeUnit.MILLISECONDS);</div><div class="line">				resultStream = new Http1xStream(this, e.source, e.sink);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			ConnectionPool arg7 = this.connectionPool;</div><div class="line">			synchronized (this.connectionPool) &#123;</div><div class="line">				this.stream = (HttpStream) resultStream;</div><div class="line">				return (HttpStream) resultStream;</div><div class="line">			&#125;</div><div class="line">		&#125; catch (IOException arg10) &#123;</div><div class="line">			throw new RouteException(arg10);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在newStream 方法中，首先调用了 findHealthyConnection，得到RealConnection对象，再根据framedConnection 是否为空，确定采取的http协议：<br>Http2xStream 代表是https请求，采用 http2.0或者spdy 协议。</p>
<p>Http1xStream 代表是http请求，采用 http1.0或者 http1.1 协议。</p>
<p>newStream 方法中又调用了 findHealthyConnection ，<br>这个方法当中又调用了 findConnection 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**来自StreamAllocation 类*/</div><div class="line"></div><div class="line">private RealConnection findHealthyConnection(int connectTimeout,</div><div class="line">int readTimeout, int writeTimeout, boolean connectionRetryEnabled,</div><div class="line">boolean doExtensiveHealthChecks) throws IOException, RouteException &#123;</div><div class="line">		while (true) &#123;</div><div class="line">			RealConnection candidate = this.findConnection(connectTimeout,</div><div class="line">					readTimeout, writeTimeout, connectionRetryEnabled);</div><div class="line">			......</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们再来看findConnection 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**来自StreamAllocation 类*/</div><div class="line"></div><div class="line">private RealConnection findConnection(int connectTimeout, int readTimeout,</div><div class="line">			int writeTimeout, boolean connectionRetryEnabled)</div><div class="line">			throws IOException, RouteException &#123;</div><div class="line">			......</div><div class="line">RealConnection pooledConnection = Internal.instance.get(</div><div class="line">					this.connectionPool, this.address, this);</div><div class="line">			......</div><div class="line">		newConnection1.connect(connectTimeout, readTimeout, writeTimeout,</div><div class="line">			......</div><div class="line">Internal.instance.put(this.connectionPool, newConnection1);</div><div class="line">		return newConnection1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>重要的看下这三个方法：</p>
<p>前面我们已经说过了get是Internal的方法，是在OkhttpClient中的static代码块中实现的，这个get方法中最终调用了ConnectPool 的get方法，看名字我们就能猜到，这儿维护了一个连接池，这个东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final Deque&lt;RealConnection&gt; connections;</div></pre></td></tr></table></figure>
<p>get 和 put 都是对它的操作。</p>
<p>OK，看下第二个方法，connect方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**来自 RealConnection 方法，实现了Connection接口*/</div><div class="line"></div><div class="line">public void connect(int connectTimeout, int readTimeout, int writeTimeout, List&lt;ConnectionSpec&gt; connectionSpecs, boolean connectionRetryEnabled) throws RouteException &#123;</div><div class="line">      if(this.protocol != null) &#123;</div><div class="line">         throw new IllegalStateException(&quot;already connected&quot;);</div><div class="line">      &#125; else &#123;</div><div class="line">         RouteException routeException = null;</div><div class="line">         ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);</div><div class="line">         Proxy proxy = this.route.proxy();</div><div class="line">         Address address = this.route.address();</div><div class="line">         if(this.route.address().sslSocketFactory() == null &amp;&amp; !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</div><div class="line">            throw new RouteException(new UnknownServiceException(&quot;CLEARTEXT communication not supported: &quot; + connectionSpecs));</div><div class="line">         &#125; else &#123;</div><div class="line">            while(this.protocol == null) &#123;</div><div class="line">               try &#123;</div><div class="line">                  this.rawSocket = proxy.type() != Type.DIRECT &amp;&amp; proxy.type() != Type.HTTP?new Socket(proxy):address.socketFactory().createSocket();</div><div class="line">                  this.connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">               &#125; catch (IOException arg10) &#123;</div><div class="line">                  Util.closeQuietly(this.socket);</div><div class="line">                  Util.closeQuietly(this.rawSocket);</div><div class="line">                  this.socket = null;</div><div class="line">                  this.rawSocket = null;</div><div class="line">                  this.source = null;</div><div class="line">                  this.sink = null;</div><div class="line">                  this.handshake = null;</div><div class="line">                  this.protocol = null;</div><div class="line">                  if(routeException == null) &#123;</div><div class="line">                     routeException = new RouteException(arg10);</div><div class="line">                  &#125; else &#123;</div><div class="line">                     routeException.addConnectException(arg10);</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  if(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(arg10)) &#123;</div><div class="line">                     throw routeException;</div><div class="line">                  &#125;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到，典型的socket连接，最终使用Okio包进行socket连接。</p>
<p>再底层先不看了，了解到主要流程就行。</p>
<p>再次回到httpEngine方法的37行，我们知道connect方法最终得到一个httpstream对象（好像OKhttp2.x版本这个方法没返回值）。<br>到这儿，sendRequest 方法我们就分析完了。篇幅太长了，所以我们下篇继续来看 readResponse() 方法。</p>
]]></content>
    
    <summary type="html">
    
      OKHttp源码从头解析，面试杀手锏
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="OKHttp" scheme="http://yoursite.com/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>安卓面试清单----OKHttp源码解析（一）</title>
    <link href="http://yoursite.com/2017/06/14/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/06/14/OkHttp源码分析（一）/</id>
    <published>2017-06-14T00:54:16.000Z</published>
    <updated>2017-07-17T09:27:41.393Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于OKHttp3.2 。</p>
<p>一个典型 OKhttp <strong>同步</strong>请求的发起是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response response = client.newCall(request).execute();</div></pre></td></tr></table></figure>
<p>在 OkHttpClient 类中, newCall 方法是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Call newCall(Request request) &#123;</div><div class="line">      return new RealCall(this, request);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>RealCall 是 Call 的实现类，那我们去 RealCall 中找，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**来自 RealCall 类*/</div><div class="line"></div><div class="line"></div><div class="line">public Response execute() throws IOException &#123;</div><div class="line">		synchronized (this) &#123;</div><div class="line">			if (this.executed) &#123;</div><div class="line">				throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">			&#125;</div><div class="line">			this.executed = true;</div><div class="line">		&#125;</div><div class="line">		Response arg1;</div><div class="line">		try &#123;</div><div class="line">			this.client.dispatcher().executed(this);</div><div class="line">			Response result = this.getResponseWithInterceptorChain(false);</div><div class="line">			if (result == null) &#123;</div><div class="line">				throw new IOException(&quot;Canceled&quot;);</div><div class="line">			&#125;</div><div class="line">			arg1 = result;</div><div class="line">		&#125; finally &#123;</div><div class="line">			this.client.dispatcher().finished(this);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return arg1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>很轻松就找到了 execute() 方法，上面代码第10行用到了一个从 OkHttpClient 获得的 Dispatcher 然后把它加入到分发器里面的队列 runningSyncCalls 中，在完成的时候会remove掉。这个队列是一个ArrayDeque。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**来自 Dispatcher 类*/</div><div class="line"></div><div class="line"></div><div class="line">synchronized void executed(RealCall call) &#123;</div><div class="line">      this.runningSyncCalls.add(call);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   synchronized void finished(Call call) &#123;</div><div class="line">      if(!this.runningSyncCalls.remove(call)) &#123;</div><div class="line">         throw new AssertionError(&quot;Call wasn\&apos;t in-flight!&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其次会执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response result = this.getResponseWithInterceptorChain(false);</div></pre></td></tr></table></figure>
<p>先到这儿，记住 <strong>getResponseWithInterceptorChain（）</strong> 方法，我们再来看异步请求：</p>
<p>也在 RealCall 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**来自 RealCall 类*/</div><div class="line"></div><div class="line"></div><div class="line">void enqueue(Callback responseCallback, boolean forWebSocket) &#123;</div><div class="line">		synchronized (this) &#123;</div><div class="line">			if (this.executed) &#123;</div><div class="line">				throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			this.executed = true;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		this.client.dispatcher().enqueue(</div><div class="line">				new RealCall.AsyncCall(responseCallback, forWebSocket));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>是不是和同步很像，但是有两点不同：</p>
<p>1、同步调用的 executed 方法，而异步调用的是分发器的 enqueue 方法。</p>
<p>2、同步传入 execute 方法的参数是 Call，异步传入 enqueue 方法的是AsyncCall，这个是什么呢，这个是 Call 里面的一个内部类，而且是一个继承了Runnable的内部类。</p>
<p>先看第一个不同点：分发器的 enqueue 方法是干什么的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自 Dispatcher 类*/</div><div class="line"></div><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line"> //判断当前运行的线程是否超过最大线程数，以及同一个请求是否要超过相同请求同时存在的最大数目</div><div class="line">      if(this.runningAsyncCalls.size() &lt; this.maxRequests &amp;&amp; this.runningCallsForHost(call) &lt; this.maxRequestsPerHost) &#123;</div><div class="line">         this.runningAsyncCalls.add(call);</div><div class="line">         //将请求放到线程池里运行</div><div class="line">         this.executorService().execute(call);</div><div class="line">      &#125; else &#123;</div><div class="line">        //不满足运行条件放到后备队列里</div><div class="line">         this.readyAsyncCalls.add(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**来自 Dispatcher 类*/</div><div class="line"></div><div class="line">public synchronized ExecutorService executorService() &#123;</div><div class="line">      if(this.executorService == null) &#123;</div><div class="line">         this.executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return this.executorService;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>很明显，这儿用线程池直接提交了这个实现了 Runable 的 AsyncCall 。<br>这是一个可缓存的线程池。</p>
<p>从上面代码我们看到异步请求是有条件限制的，默认最多64个请求，而对同一个主机的最大请求默认最多同时存在5个。这两个值都是可以更改的，Dispatcher 提供了相关方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class Dispatcher &#123;</div><div class="line">   private int maxRequests = 64;</div><div class="line">   private int maxRequestsPerHost = 5;</div><div class="line">   private ExecutorService executorService;</div><div class="line">   private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque();</div><div class="line">   private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque();</div><div class="line">   private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque();</div><div class="line"></div><div class="line">   public Dispatcher(ExecutorService executorService) &#123;</div><div class="line">      this.executorService = executorService;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自 Dispatcher 类*/</div><div class="line"></div><div class="line"> private int runningCallsForHost(AsyncCall call) &#123;</div><div class="line">      int result = 0;</div><div class="line">      Iterator arg2 = this.runningAsyncCalls.iterator();</div><div class="line"></div><div class="line">      while(arg2.hasNext()) &#123;</div><div class="line">         AsyncCall c = (AsyncCall)arg2.next();</div><div class="line">          通过比较每个请求的主机地址，一样代表同一个请求</div><div class="line">         if(c.host().equals(call.host())) &#123;</div><div class="line">            ++result;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**来自 RealCall类*/</div><div class="line"></div><div class="line">String host() &#123;</div><div class="line">			return RealCall.this.originalRequest.url().host();</div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<p>OK，第一个不同点已经分析完，再来看看第二个不同点 AsyncCall 是个什么东东？</p>
<p>AsyncCall 继承自 NamedRunnable ，NamedRunnable 实现了 Runnable 。NamedRunnable  只是给这个 Runnable 起了个名字而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public NamedRunnable(String format, Object... args) &#123;</div><div class="line">      this.name = String.format(format, args);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>再来看看AsyncCall 的run里面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**来自 NamedRunnable 类*/</div><div class="line">public final void run() &#123;</div><div class="line">      String oldName = Thread.currentThread().getName();</div><div class="line">      Thread.currentThread().setName(this.name);</div><div class="line">      try &#123;</div><div class="line">         this.execute();</div><div class="line">      &#125; finally &#123;</div><div class="line">         Thread.currentThread().setName(oldName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">	 protected abstract void execute();</div></pre></td></tr></table></figure>
<p>显然AsyncCall的execute才是核心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自 RealCall 的内部类 AsyncCall 类，继承自 NamedRunnable */</div><div class="line"></div><div class="line">protected void execute() &#123;</div><div class="line">			boolean signalledCallback = false;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				Response e = RealCall.this.getResponseWithInterceptorChain(this.forWebSocket);</div><div class="line">				if (RealCall.this.canceled) &#123;</div><div class="line">					signalledCallback = true;</div><div class="line">	//若请求被取消，则回调 onFailure	</div><div class="line">	 			this.responseCallback.onFailure(RealCall.this,</div><div class="line">							new IOException(&quot;Canceled&quot;));</div><div class="line">				&#125; else &#123;</div><div class="line">					signalledCallback = true;</div><div class="line">	//若成功返回Response，则回调 onResponse</div><div class="line">		this.responseCallback.onResponse(RealCall.this, e);</div><div class="line">				&#125;</div><div class="line">			&#125; catch (IOException arg5) &#123;</div><div class="line">				if (signalledCallback) &#123;</div><div class="line">					Internal.logger.log(Level.INFO, &quot;Callback failure for &quot;</div><div class="line">							+ RealCall.this.toLoggableString(), arg5);</div><div class="line">				&#125; else &#123;</div><div class="line">					this.responseCallback.onFailure(RealCall.this, arg5);</div><div class="line">				&#125;</div><div class="line">			&#125; finally &#123;</div><div class="line">				RealCall.this.client.dispatcher().finished(this);</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>在代码第八行我们又看到了<strong>getResponseWithInterceptorChain()</strong>方法。 可以看到，异步和同步一样，最后都执行到了这个方法并返回 Response 。<br>那我们就来看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**来自 RealCall类 */</div><div class="line"></div><div class="line">private Response getResponseWithInterceptorChain(boolean forWebSocket)throws IOException &#123;</div><div class="line">		RealCall.ApplicationInterceptorChain chain = new RealCall.ApplicationInterceptorChain(</div><div class="line">				0, this.originalRequest, forWebSocket);</div><div class="line">		return chain.proceed(this.originalRequest);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>创建了一个ApplicationInterceptorChain ，并且第一个参数传入0，这个0是有特殊用法的，涉及到OKHttp里面的一个功能叫做拦截器，从getResponseWithInterceptorChain这个名字里其实也能看出一二。先看看proceed做了什么：</p>
<p>OKHttp增加的拦截器机制，先来看看官方文档对Interceptors 的解释 :</p>
<blockquote>
<p>Interceptors are a powerful mechanism that can monitor, rewrite, and<br>retry calls.</p>
</blockquote>
<p>解释下就是拦截器可以用来转换，重试，重写请求的机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自 RealCall 的内部类 ApplicationInterceptorChain，实现了 Chain 接口 */</div><div class="line"></div><div class="line">public Response proceed(Request request) throws IOException &#123;</div><div class="line">			  /**先判断是否有拦截器，如果有则首先执行拦截器重写的 intercept 方法，执行完自己写的代码之后，并手动调用 proceed()方法再次判断是否还有拦截器。</div><div class="line">			  </div><div class="line">			   若已经没有拦截器存在的话就执行 getResponse()方法*/</div><div class="line">			if (this.index &lt; RealCall.this.client.interceptors().size()) &#123;</div><div class="line">				RealCall.ApplicationInterceptorChain chain = RealCall.this.new ApplicationInterceptorChain(</div><div class="line">						this.index + 1, request, this.forWebSocket);</div><div class="line">				Interceptor interceptor = (Interceptor) RealCall.this.client</div><div class="line">						.interceptors().get(this.index);</div><div class="line">				Response interceptedResponse = interceptor.intercept(chain);</div><div class="line">				if (interceptedResponse == null) &#123;</div><div class="line">					throw new NullPointerException(&quot;application interceptor &quot;</div><div class="line">							+ interceptor + &quot; returned null&quot;);</div><div class="line">				&#125; else &#123;</div><div class="line">					return interceptedResponse;</div><div class="line">				&#125;</div><div class="line">			&#125; else &#123;</div><div class="line">				return RealCall.this.getResponse(request, this.forWebSocket);</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>创建 ApplicationInterceptorChain 的时候第一个参数为0，则this.index==0；</p>
<p>若没有拦截器的话走 else，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return RealCall.this.getResponse(request, this.forWebSocket);</div></pre></td></tr></table></figure></p>
<p>若有1个拦截器的话：</p>
<p>则0&lt;1，回调拦截器中的 intercept 方法。</p>
<p>当我们在拦截器中手动调用 process 后再次回到方法中检查是否有拦截器，此时不满足条件，走 else，最终还是回到了 getResponse 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ApplicationInterceptorChain(int index, Request request,</div><div class="line">				boolean forWebSocket) &#123;</div><div class="line">			this.index = index;</div><div class="line">			this.request = request;</div><div class="line">			this.forWebSocket = forWebSocket;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>看下我当时用的一个用于获取打印http请求信息的拦截器（包括请求头，body，url等等，直接打印）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by QHT on 2017-04-05.</div><div class="line"> */</div><div class="line">public class OK_LoggingInterceptor implements Interceptor&#123;</div><div class="line">        @SuppressLint(&quot;DefaultLocale&quot;)</div><div class="line">        @Override</div><div class="line">        public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">            //这个chain里面包含了request和response，所以你要什么都可以从这里拿</div><div class="line">            Request request = chain.request();</div><div class="line"></div><div class="line">            long t1 = System.nanoTime();//请求发起的时间</div><div class="line">            LogUtil.e(String.format(&quot;发送请求 %s on %s%n%s&quot;,</div><div class="line">                    request.url(), chain.connection(), request.headers()));</div><div class="line">			//自定义拦截器必须执行 proceed 方法,以便继续判断是否还存在拦截器</div><div class="line">            Response response = chain.proceed(request);</div><div class="line"></div><div class="line">            long t2 = System.nanoTime();//收到响应的时间</div><div class="line"></div><div class="line">            //这里不能直接使用response.body().string()的方式输出日志</div><div class="line">            //因为response.body().string()之后，response中的流会被关闭，程序会报错，我们需要创建出一个新的response给应用层处理</div><div class="line">            ResponseBody responseBody = response.peekBody(1024 * 1024);</div><div class="line"></div><div class="line">            LogUtil.e(String.format(&quot;接收响应: [%s] %n返回json:【%s】 %.1fms%n%s&quot;,</div><div class="line">                    response.request().url(),</div><div class="line">                    responseBody.string(),</div><div class="line">                    (t2 - t1) / 1e6d,</div><div class="line">                    response.headers()));</div><div class="line"></div><div class="line">            return response;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个拦截器发送完请求后打印的效果是这样的：</p>
<hr>
<p>H快递: com.qht.blog2.Net.OK_LoggingInterceptor.intercept(OK_LoggingInterceptor.java:25)<br>H快递:    发送请求 <a href="http://www.kuaidi100.com/query?type=yunda&amp;postid=7700008953907" target="_blank" rel="external">http://www.kuaidi100.com/query?type=yunda&amp;postid=7700008953907</a> on null<br>H快递: com.qht.blog2.Net.OK_LoggingInterceptor.intercept(OK_LoggingInterceptor.java:37)<br>H快递:    接收响应: [<a href="http://www.kuaidi100.com/query?type=yunda&amp;postid=7700008953907" target="_blank" rel="external">http://www.kuaidi100.com/query?type=yunda&amp;postid=7700008953907</a>]<br>                                                  返回json:【】 370.2ms<br>                                                  Server: nginx<br>                                                  Date: Tue, 13 Jun 2017 15:21:58 GMT<br>                                                  Content-Type: text/html;charset=UTF-8<br>                                                  Transfer-Encoding: chunked<br>                                                  Connection: keep-alive<br>                                                  P3P: CP=”IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT”<br>                                                  Cache-Control: no-cache<br>                                                  Vary: Accept-Encoding</p>
<hr>
<p>在处理完拦截器操作后，就进入到重要的getResponse方法，真正的去进行发送请求，处理请求，接收返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**来自RealCall类 */</div><div class="line"></div><div class="line">Response getResponse(Request request, boolean forWebSocket)</div><div class="line">			throws IOException &#123;</div><div class="line">		RequestBody body = request.body();</div><div class="line">		if (body != null) &#123; </div><div class="line">			Builder followUpCount = request.newBuilder();</div><div class="line">			MediaType releaseConnection = body.contentType();</div><div class="line">			if (releaseConnection != null) &#123;</div><div class="line">				followUpCount.header(&quot;Content-Type&quot;,</div><div class="line">						releaseConnection.toString());</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			long response = body.contentLength();</div><div class="line">			if (response != -1L) &#123;</div><div class="line">				followUpCount.header(&quot;Content-Length&quot;, Long.toString(response));</div><div class="line">				followUpCount.removeHeader(&quot;Transfer-Encoding&quot;);</div><div class="line">			&#125; else &#123;</div><div class="line">				followUpCount.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</div><div class="line">				followUpCount.removeHeader(&quot;Content-Length&quot;);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			request = followUpCount.build();</div><div class="line">		&#125;</div><div class="line"> //新建HttpEngine，用于进行发送请求和读取答复的细节处理</div><div class="line">		this.engine = new HttpEngine(this.client, request, false, false,</div><div class="line">				forWebSocket, (StreamAllocation) null, (RetryableSink) null,</div><div class="line">				(Response) null);</div><div class="line">		int arg19 = 0;</div><div class="line"></div><div class="line">		while (!this.canceled) &#123;</div><div class="line">			boolean arg20 = true;</div><div class="line">			boolean arg14 = false;</div><div class="line"></div><div class="line">			StreamAllocation streamAllocation;</div><div class="line">			label173: &#123;</div><div class="line">				label172: &#123;</div><div class="line">					try &#123;</div><div class="line">						HttpEngine followUp;</div><div class="line">						try &#123;</div><div class="line">							arg14 = true;</div><div class="line">							this.engine.sendRequest();</div><div class="line">							this.engine.readResponse();</div><div class="line">							arg20 = false;</div><div class="line">							arg14 = false;</div><div class="line">							break label173;</div><div class="line">						&#125; catch (RequestException arg15) &#123;</div><div class="line">							throw arg15.getCause();</div><div class="line">						&#125; catch (RouteException arg16) &#123;</div><div class="line">							followUp = this.engine.recover(</div><div class="line">									arg16.getLastConnectException(),</div><div class="line">									(Sink) null);</div><div class="line">							if (followUp == null) &#123;</div><div class="line">								throw arg16.getLastConnectException();</div><div class="line">							&#125;</div><div class="line">						&#125; catch (IOException arg17) &#123;</div><div class="line">							followUp = this.engine.recover(arg17, (Sink) null);</div><div class="line">							if (followUp != null) &#123;</div><div class="line">								arg20 = false;</div><div class="line">								this.engine = followUp;</div><div class="line">								arg14 = false;</div><div class="line">								break label172;</div><div class="line">							&#125;</div><div class="line"></div><div class="line">							throw arg17;</div><div class="line">						&#125;</div><div class="line"></div><div class="line">						arg20 = false;</div><div class="line">						this.engine = followUp;</div><div class="line">						arg14 = false;</div><div class="line">					&#125; finally &#123;</div><div class="line">						if (arg14) &#123;</div><div class="line">							if (arg20) &#123;</div><div class="line">								StreamAllocation streamAllocation1 = this.engine</div><div class="line">										.close();</div><div class="line">								streamAllocation1.release();</div><div class="line">							&#125;</div><div class="line"></div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					if (arg20) &#123;</div><div class="line">						streamAllocation = this.engine.close();</div><div class="line">						streamAllocation.release();</div><div class="line">					&#125;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				if (arg20) &#123;</div><div class="line">					streamAllocation = this.engine.close();</div><div class="line">					streamAllocation.release();</div><div class="line">				&#125;</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (arg20) &#123;</div><div class="line">				StreamAllocation arg21 = this.engine.close();</div><div class="line">				arg21.release();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			Response arg22 = this.engine.getResponse();</div><div class="line">			 //得到该请求对应的后续请求，比如重定向之类的</div><div class="line">			Request arg23 = this.engine.followUpRequest();</div><div class="line">			if (arg23 == null) &#123;</div><div class="line">				if (!forWebSocket) &#123;</div><div class="line">					this.engine.releaseStreamAllocation();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				return arg22;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			streamAllocation = this.engine.close();</div><div class="line">			++arg19;</div><div class="line">			if (arg19 &gt; 20) &#123;</div><div class="line">				streamAllocation.release();</div><div class="line">				throw new ProtocolException(&quot;Too many follow-up requests: &quot;</div><div class="line">						+ arg19);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (!this.engine.sameConnection(arg23.url())) &#123;</div><div class="line">				streamAllocation.release();</div><div class="line">				streamAllocation = null;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			this.engine = new HttpEngine(this.client, arg23, false, false,</div><div class="line">					forWebSocket, streamAllocation, (RetryableSink) null, arg22);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		this.engine.releaseStreamAllocation();</div><div class="line">		throw new IOException(&quot;Canceled&quot;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>没错，就是这么长。<br>可以看到如果是post请求，先做一定的头部处理，然后新建一个HttpEngine去处理具体的操作，通过sendRequest发送具体请求操作，readResponse对服务器的答复做一定处理，最后得到从服务器返回的Response，讲到这里，我们整个的流程大概疏通了，代码贴了很多，简单的可以用下面一张图概括 ：<br><img src="http://img.blog.csdn.net/20170614115053211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>getResponse() 方法的内容还有很多，下篇再分析。</p>
]]></content>
    
    <summary type="html">
    
      OKHttp源码从头解析，面试杀手锏
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="OKHttp" scheme="http://yoursite.com/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>安卓面试清单</title>
    <link href="http://yoursite.com/2017/06/05/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2017/06/05/安卓面试清单/</id>
    <published>2017-06-05T00:54:16.000Z</published>
    <updated>2017-06-05T13:47:12.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Activity相关"><a href="#一、Activity相关" class="headerlink" title="一、Activity相关:"></a><strong>一、Activity相关:</strong></h1><h2 id="1-Activity的加载模式。"><a href="#1-Activity的加载模式。" class="headerlink" title="1. Activity的加载模式。"></a>1. Activity的加载模式。</h2><p><a href="http://blog.csdn.net/mynameishuangshuai/article/details/51491074" target="_blank" rel="external">http://blog.csdn.net/mynameishuangshuai/article/details/51491074</a></p>
<p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p>
<p>注：某些适用于清单文件的启动模式不可用作 Intent 标志，同样，某些可用作 Intent 标志的启动模式无法在清单文件中定义。</p>
<p><strong>standard-默认模式</strong></p>
<p>  这个模式是默认的启动模式，即标准模式，在不指定启动模式的前提下，系统默认使用该模式启动Activity，每次启动一个Activity都会重写创建一个新的实例，不管这个实例存不存在，这种模式下，谁启动了该模式的Activity，该Activity就属于启动它的Activity的任务栈中。这个Activity它的onCreate()，onStart()，onResume()方法都会被调用。</p>
<p><strong>singleTop模式分3种情况</strong></p>
<ul>
<li>当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法</li>
<li>当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例</li>
<li>当前栈中不存在该Activity的实例时，其行为同standard启动模式</li>
</ul>
<p>standard和singleTop启动模式都是在原任务栈中新建Activity实例，不会启动新的Task，即使你指定了taskAffinity属性。</p>
<p>那么什么是taskAffinity属性呢，可以简单的理解为任务相关性。</p>
<ul>
<li><p>这个参数标识了一个Activity所需任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。</p>
</li>
<li><p>我们可以单独指定每一个Activity的taskAffinity属性覆盖默认值。</p>
</li>
<li><p>一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。</p>
</li>
<li><p>在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。</p>
</li>
</ul>
<ul>
<li><p>为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。</p>
</li>
<li><p>很重要的一点taskAffinity属性不对standard和singleTop模式有任何影响，即时你指定了该属性为其他不同的值，这两种启动模式下不会创建新的task（如果不指定即默认值，即包名）</p>
</li>
</ul>
<p><strong>singleTask-栈内复用模式</strong> <strong>（MainActivity时会用到）</strong></p>
<p>这个模式十分复杂，有各式各样的组合。在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且会回调该实例的onNewIntent方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。 </p>
<ul>
<li><p>singleTask启动模式启动Activity时，首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈。</p>
</li>
<li><p>如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去。</p>
</li>
<li><p>如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例。</p>
<ul>
<li><p>如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法。</p>
</li>
<li><p>如果不存在该实例，则新建Activity，并入栈。</p>
</li>
</ul>
</li>
</ul>
<p>此外，我们可以将两个不同App中的Activity设置为相同的taskAffinity，这样虽然在不同的应用中，但是Activity会被分配到同一个Task中去。</p>
<p><strong>singleInstance-全局唯一模式</strong></p>
<p>该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即<strong>整个系统</strong>中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 </p>
<p>整个系统即为Android系统，允许不同的APP应用同用一个任务栈。</p>
<hr>
<h2 id="2-Application、Activity、Fragment、broadcastReceiver、service生命周期，横竖屏切换时候Activity的生命周期"><a href="#2-Application、Activity、Fragment、broadcastReceiver、service生命周期，横竖屏切换时候Activity的生命周期" class="headerlink" title=" 2. Application、Activity、Fragment、broadcastReceiver、service生命周期，横竖屏切换时候Activity的生命周期 "></a> 2. Application、Activity、Fragment、broadcastReceiver、service生命周期，横竖屏切换时候Activity的生命周期 </h2><p>###Application:</p>
<p>Application和Activity,Service一样,是android框架的一个系统组件，当android程序启动时系统会创建一个application对象，用来存储系统的一些信息。application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局的单例的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以通过Application来进行一些，数据传递，数据共享 等,数据缓存等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class BaseApplication extends Application &#123;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void onCreate() &#123;  </div><div class="line">            // 程序创建的时候执行  </div><div class="line">            super.onCreate();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void onTerminate() &#123;  </div><div class="line">           /**</div><div class="line">	       * onTerminate()会在app关闭的时候调用,但是就像onDestroy()一样，</div><div class="line">	       * 不能保证一定会被调用。</div><div class="line">	       * 系统内存不足可能强制杀掉你的进程，这时候onterminate就不调了。</div><div class="line">	       * 所以最好不要依赖这个方法做重要的处理，</div><div class="line">	       * 这个方法最多可以用来销毁一写对象，清除一下缓存，</div><div class="line">	       * 但是也并不能保证一定会清除掉，其他操作，例如想在程序结束保存               </div><div class="line">	       * 数据，用这个方法明显是错误的。</div><div class="line">	       */</div><div class="line">            super.onTerminate();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void onLowMemory() &#123;  </div><div class="line">            /**onLowMemory()在内存比较紧张时,根据优先级把后台程序杀死  </div><div class="line">            时,系统回调他,它用在14之前,14之后就出现了onTrimMemory()  </div><div class="line">            */</div><div class="line">            super.onLowMemory();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void onTrimMemory(int level) &#123;  </div><div class="line">          /**</div><div class="line">	       * 程序在内存清理的时候执行（回收内存）  </div><div class="line">	       * HOME键退出应用程序、长按MENU键，打开Recent TASK都会执行。</div><div class="line">	       */</div><div class="line">            super.onTrimMemory(level);  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void onConfigurationChanged(Configuration newConfig) &#123;  </div><div class="line">            super.onConfigurationChanged(newConfig);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###Activity:</p>
<p><img src="http://img.blog.csdn.net/20170522194639623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170522162446466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170522162759281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>程序启动运行并结束上述生命周期的方法执行顺序是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onCreate –&gt; onContentChanged –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume –&gt; onPause –&gt; onStop –&gt; onDestroy</div></pre></td></tr></table></figure>
<p> <strong>- onContentChanged</strong></p>
<p>onContentChanged()是Activity中的一个回调方法 当Activity的布局改动时，即setContentView()或者addContentView()方法执行完毕时就会调用该方法， 例如，Activity中各种View的findViewById()方法都可以放到该方法中。</p>
<p> <strong>- onPostCreate、onPostResume</strong></p>
<p>onPostCreate方法是指onCreate方法彻底执行完毕的回调，onPostResume类似，这两个方法官方说法是一般不会重写，现在知道的做法也就只有在使用ActionBarDrawerToggle的使用在onPostCreate需要在屏幕旋转时候等同步下状态，Google官方提供的一些实例就是如下做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onPostCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onPostCreate(savedInstanceState);</div><div class="line"></div><div class="line">    // Sync the toggle state after onRestoreInstanceState has occurred.</div><div class="line">    mDrawerToggle.syncState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>- onPause、 onStop</strong></p>
<p>这里顺便再提一下onPause、 onStop的区别， onPause是在整个窗口被半遮盖或者半透明的时候会执行，而onStop则是在整个窗口被完全遮盖才会触发， 触发onStop的方法之前必定会触发onPause方法。</p>
<p> <strong>- onCreate、 onStart</strong></p>
<p>onCreate方法会在第一次创建的时候执行，紧接着便会执行onStart方法，之后页面被完全遮挡会执行onStop方法，再返回的时候一般便会执行onRestart –&gt; onStart方法， 但是如果如果这时候App内存不够需要更多的内存的时候，App便会杀死该进程，结束掉该Activity，所以这时候再返回的时候便会重新执行onCreate –&gt; onStart –&gt; onResume方法。</p>
<p> <strong>- onSaveInstanceState、 onRestoreInstanceState</strong></p>
<ul>
<li>onSaveInstanceState</li>
</ul>
<p>onSaveInstanceState字面理解就是保存实例的状态，当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。</p>
<p>注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有这么几种情况：</p>
<ol>
<li>当用户按下HOME键时</li>
</ol>
<p>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>
<ol>
<li>长按HOME键，选择运行其他的程序时。</li>
<li>按下电源按键（关闭屏幕显示）时。 </li>
<li>从activity A中启动一个新的activity时。</li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>
</ol>
<p>在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p>
<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。</p>
<ul>
<li>onRestoreInstanceState</li>
</ul>
<p>onSaveInstanceState字面理解就是恢复实例的状态, 需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p>
<p>不过大多数情况下也是很少使用onRestoreInstanceState方法的，经常我们还是在onCreate方法里直接恢复状态的，onCreate方法里本身会有一个Bundle参数的，很多时候我们是这样使用的。（onCreate在onStart之前调用，而onRestoreInstanceState是在onStart之后调用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected void onSaveInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">    super.onSaveInstanceState(icicle);</div><div class="line">    savedInstanceState.putLong(&quot;param&quot;, value);</div><div class="line">&#125;</div><div class="line">public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    if (savedInstanceState != null)&#123;</div><div class="line">        value = savedInstanceState.getLong(&quot;param&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>来结合一些特定的使用场景来分析下Activity的生命周期。</strong></p>
<p>首次启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onCreate –&gt; onStart –&gt; onResume</div></pre></td></tr></table></figure>
<p>按下返回按键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPause –&gt; onStop –&gt; onDestroy</div></pre></td></tr></table></figure>
<p>按Home键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPause –&gt; onSaveInstanceState –&gt; onStop</div></pre></td></tr></table></figure>
<p>再次打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onRestart –&gt; onStart –&gt; onResume</div></pre></td></tr></table></figure>
<p>屏幕旋转</p>
<p>如果你不做任何配置，启动Activity会执行如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onCreate –&gt; onStart –&gt; onResume</div></pre></td></tr></table></figure>
<p>之后旋转屏幕，则Activity会被销毁并重新创建，之后便会执行如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPause –&gt; onSaveInstanceState –&gt; onStop –&gt; onDestroy –&gt; onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume</div></pre></td></tr></table></figure>
<p>在AndroidManifest配置文件里声明android:configChanges属性<br>默认屏幕旋转会重新创建，当然可以通过在配置文件里加上如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;（sdk&gt;13时需加上screenSize）</div></pre></td></tr></table></figure>
<p>这个时候再旋转屏幕便不会销毁Activity，这时候再旋转屏幕可以看到只会执行onConfigurationChanged方法，有什么在屏幕旋转的逻辑可以重写这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void onConfigurationChanged(Configuration newConfig) &#123;</div><div class="line">    if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123;</div><div class="line">        // TODO:</div><div class="line">    &#125;</div><div class="line">    super.onConfigurationChanged(newConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FirstActivity打开SecondActivity</p>
<p>FirstActivity打开SecondActivity，这时候FirstActivity生命周期的方法是这样的： onPause –&gt; onSaveInstanceState –&gt; onStop, 这个时候在SecondActivity按返回键，FirstActivity会有以下集中情况：</p>
<p>正常情况下会执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onRestart -&gt; onStart -&gt; onResume</div></pre></td></tr></table></figure>
<p>当系统由于要回收内存而把 activity 销毁时，</p>
<p>Activity在onPause或者onStop状态下都有可能遇到由于突发事件系统需要回收内存，之后的onDestroy方法便不会再执行，这时候会执行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume</div></pre></td></tr></table></figure>
<hr>
<h1 id="二、Handler相关"><a href="#二、Handler相关" class="headerlink" title="二、Handler相关:"></a><strong>二、Handler相关:</strong></h1><h2 id="1-Handler机制。"><a href="#1-Handler机制。" class="headerlink" title=" 1. Handler机制。"></a> 1. Handler机制。</h2><p>1、 <a href="http://blog.csdn.net/lmj623565791/article/details/38377229/" target="_blank" rel="external">（鸿洋Android 异步消息处理机制 让你深入理解Looper、Handler、Message三者关系）</a></p>
<p>2、子线程更新UI问题？(不严谨）：</p>
<ul>
<li><p>情况1：若在子线程(需要标记)创建ViewRoot对象，调用windowmanager的addview()方法，添加对应的视图，则可以更新UI，参考：<strong>忘记地址了</strong>……</p>
</li>
<li><p>情况2：在onresume()之前，比如oncreate()，开启子线程并且更新UI，不会报错，因为此时还没有执行requestlayout(),也未执行checkthread()方法。参考自己的博客（<a href="http://blog.csdn.net/u012534831/article/details/52056072" target="_blank" rel="external">子线程真的不能更新UI吗？</a>）</p>
</li>
</ul>
<p>UI控件是线程不安全的。若在子线程中更新UI，会产生竞争、死锁等问题，多个子线程更新UI会使UI控件混乱，且不可控制。</p>
<h2 id="2-Looper。"><a href="#2-Looper。" class="headerlink" title=" 2. Looper。"></a> 2. Looper。</h2><p>1、   如何保证一个线程只有一个Looper？</p>
<p> Looper.prepare()方法已经保证了一个线程只能拥有一个Looper实例。但是其中是使用ThreadLocal进行保存这个looper对象的。那么ThreadLocal怎么保证这个looper唯一呢，而不是作为一个同步共享变量呢？</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></p>
<p>  阅读上文（注意阅读评论，作者原文内容部分有歧义）我们可以知道：</p>
<p>一个线程内部可以创建多个ThreadLocal，每个ThreadLocal维护一个ThreadLocalMap，每个ThreadLocalMap的key（键）为ThreadLocal对象，我们需要保存的任何对象作为value（值）；</p>
<p>在looper.prepare()方法里面只创建了一个sThreadLocal对象，通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sThreadLocal.set(new Looper(true));</div></pre></td></tr></table></figure>
<p> 方法可以保存此looper的引用（某些地方称为副本，并不准确），可见此looper 在每个线程中是唯一的，因为：</p>
<ol>
<li>每个sThreadLocal只能存放一个键值对。</li>
<li>下面这段代码保证了looper不能被new两次。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (sThreadLocal.get() != null) &#123;  </div><div class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);  </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程:"></a><strong>三、多线程:</strong></h1><h2 id="1-安卓多线程的方式有哪些。"><a href="#1-安卓多线程的方式有哪些。" class="headerlink" title=" 1. 安卓多线程的方式有哪些。"></a> 1. 安卓多线程的方式有哪些。</h2><p>###安卓多线程方式：</p>
<p> Handler+Thread（sendmessage() 和 handler.post()）</p>
<p>AsynTask</p>
<p>ThreadPoolExecutor</p>
<p>IntentService</p>
<p>###安卓异步更新UI方式：</p>
<p>sendmessage() 和 handler.post()</p>
<p>AsynTask</p>
<p>RunOnUiThread</p>
<p>view.post()（需要确保View已经attach到window）详见<a href="http://blog.csdn.net/a740169405/article/details/69668957" target="_blank" rel="external">View#post与Handler#post的区别，以及导致的内存泄漏分析</a></p>
<p>###详解几种线程池：</p>
<p><a href="http://blog.csdn.net/u012702547/article/details/52259529" target="_blank" rel="external">Android开发之线程池使用总结</a></p>
<p>###多线程面试基础知识点-java教程：</p>
<ol>
<li>什么是进程？什么是线程？进程与线程的关系是怎样的？<br>【答】进程：进程是一个可并发的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。<br>线程：线程是操作系统进程中能够独立执行的实体，是处理器调度和分派的基本单位。<br>线程是进程的组成部分，每个进程内允许包含多个并发执行的线程。</li>
</ol>
<ol>
<li>操作系统为什么要支持多线程技术？<br>【答】操作系统采用进程机制能够减少程序并发时所付出的时空开销，使得并发粒度更细，并发性更好，提高了资源使用率和系统效率。<ol>
<li>Java为什么要支持线程？什么场合需要使用多线程程序设计？<br>【答】支持多线程能充分发挥硬件的并发性，消除处理器和I/O设备的互等现象，提高系统效率。 一般一下场合需要使用多线程：1、程序包好复杂的计算任务时，主要是利用多线程获取更所得CPU时间。2、处理速度较慢的外围设备。3、程序设计自身的需要。</li>
<li>Java提供了哪些接口和类实现多线程机制？<br>【答】Java主要提供了java.lang.Runnable接口和Thread线程类来实现多线程机制。</li>
<li>一个线程对象的生命周期有哪几种状态构成？各状态之间是如何变化的？<br>【答】<br>线程对象的生命周期主要包括：新建态、就绪态和运行态、阻塞态和等待态、终止态。新建态通过start()方法是线程成为运行态，当运行态遇到sleep()或wait()方法时就进入等待态，而当sleep()时间到或通过notify()方法线程就又进入了运行态;当运行态遇到synchronized()方法时就进入阻塞态,当线程获得互斥锁使用权时就又到了运行态；当线程的run()方法结束时整个线程就进入了终止态，整个线程结束。</li>
<li>Java提供了哪些方法能够改变线程状态？程序中能够调度线程立即执行吗？<br>【答】Java中提供了start()方法来启动已创建的线程对象；sleep()方法使当前线程睡眠若干毫秒，线程有运行态进入等待态，但是不交出临界区的锁；yield() 方法暂停当前线程的执行，允许其他线程竞争CPU；stop()方法来结束一个线程；wait()方法将本线程设为等待态；notify() 方法来唤醒当前处于等待态的线程；interrupt()方法改变当前线程的中断状态，但是当前线程还可以继续执行。</li>
<li>什么是线程的优先级？设置线程优先级有什么作用？<br>【答】每个线程被执行的优先顺序即为线程的优先级，默认优先级为5。当创建了多个线程并要执行这些线程时，操作系统不知到底该执行哪个线程，当设置好优先级后，程序首先会执行优先级最高的线程，然后依次执行下去。这样处理器将会合理而且充实的额被利用，不会造成资源的浪费或者运行的混乱。</li>
<li>线程按什么规则排队等待？<br>【答】线程按优先级排队，线程调度语句优先级基础上的“先到先服务”原则</li>
<li>多线程间共享数据时会发生怎样的并发执行错误？<br>【答】当几个线程共享数据时，一个线程的执行可能影响其他线程的执行结果，并导致错误的程序运行结果。</li>
<li>在什么情况下需要采用线程同步机制？<br>【答】当并发执行的多个线程间需要共享资源或交换数据时，各个线程执行时相互之间会干扰或影响其他线程的执行结果，这时就需要采用线程同步机制。</li>
<li>关键字synchronized是什么含义？为什么wait()和notify()方法要与synchronized同时使用？<br>【答】synchronized用于声明一段程序为临界区，使线程对临界资源采用互斥使用方式。<br>wait()和notify()不是属于线程类，而是每一个对象都具有的方法，而且这两个方法都和对象锁有关，有锁的地方必有synchronized()方法，故wait()和notify()方法要与synchronized同时使用。</li>
<li>明sleep()和wait()方法的异同。<br>【答】wait是Object类的方法，sleep与yield都是Thread类的方法。wait调用的时候需要注意的是该方法是释放锁标志的，而sleep在调用的时候是紧紧抱着锁标志的，也就是等他完全执行完成了才可以让其他线程来访问的<br>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。</li>
<li>一个对象为什么需要调用wait()方法使当前线程等待？<br>【答】wait()使当前线程进入停滞状态时，还会释放当前线程所占有的“锁标志”， 从而使线程所在对象中的其它synchronized数据可被别的线程使用。当调用sleep()方法时，该线程不会释放当前线程所占有的“锁标志”。</li>
<li>什么是死锁？什么情况下会死锁？<br>【答】由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。<br>当多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序处于非正常终止，才会产生死锁。</li>
</ol>
</li>
</ol>
<h1 id="四、ANR异常发生条件"><a href="#四、ANR异常发生条件" class="headerlink" title="四、ANR异常发生条件:"></a><strong>四、ANR异常发生条件:</strong></h1><p>###发生条件：</p>
<p>ANR 一般有三种类型：</p>
<ul>
<li><p>KeyDispatchTimeout(5 seconds) –主要类型</p>
<p> 按键或触摸事件在特定时间内无响应</p>
</li>
<li><p>BroadcastTimeout(10 seconds)</p>
<p>BroadcastReceiver在特定时间内无法处理完成</p>
</li>
<li><p>ServiceTimeout(20 seconds) –小概率类型</p>
</li>
</ul>
<p>超时的原因一般有两种：</p>
<ol>
<li>当前的事件没有机会得到处理（UI线程正在处理前一个事件没有及时完成或者looper被某种原因阻塞住）。</li>
<li>当前的事件正在处理，但没有及时完成。<br>UI线程尽量只做跟UI相关的工作，耗时的工作（数据库操作，I/O，连接网络或者其他可能阻碍 UI线程的操作）放入单独的线程处理，尽量用Handler来处理 UI thread 和 thread 之间的交互。<br>UI线程主要包括如下：<br>Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()<br>AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()<br>Mainthread handler: handleMessage(), post(runnable r)</li>
</ol>
<p>###如何分析ANR:</p>
<p>查找 ANR 的方式：</p>
<ul>
<li>导出/data/data/anr/traces.txt，找出函数和调用过程，分析代码 </li>
<li>通过 LOG 查找</li>
</ul>
<h1 id="五、自定义View和ViewGroup"><a href="#五、自定义View和ViewGroup" class="headerlink" title="五、自定义View和ViewGroup:"></a><strong>五、自定义View和ViewGroup:</strong></h1><p>###自定义View：</p>
<p>1、<a href="http://www.jianshu.com/p/d507e3514b65#" target="_blank" rel="external">教你步步为营掌握自定义View(修改原文中广播为 Timer更好)</a><br>2、个人项目 H-Express 自定义时间轴(待完善)</p>
<p>###自定义ViewGroup：</p>
<p><a href="http://www.jianshu.com/p/5e61b6af4e4c" target="_blank" rel="external">教你步步为营掌握自定义ViewGroup</a></p>
<h1 id="六、安卓事件分发处理"><a href="#六、安卓事件分发处理" class="headerlink" title="六、安卓事件分发处理:"></a><strong>六、安卓事件分发处理:</strong></h1><p><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a></p>
<p><a href="http://www.jianshu.com/p/2be492c1df96" target="_blank" rel="external">可能是讲解Android事件分发最好的文章</a></p>
<h1 id="七、GC算法"><a href="#七、GC算法" class="headerlink" title="七、GC算法:"></a><strong>七、GC算法:</strong></h1><p><a href="http://www.cnblogs.com/sunfie/p/5125283.html" target="_blank" rel="external">JVM学习之GC常用算法</a></p>
<p><a href="http://www.jianshu.com/p/24c074138efa" target="_blank" rel="external">你不得不了解的JVM（一、二）</a></p>
<h1 id="八、四大引用"><a href="#八、四大引用" class="headerlink" title="八、四大引用:"></a><strong>八、四大引用:</strong></h1><p><a href="http://blog.csdn.net/hejjunlin/article/details/52637333" target="_blank" rel="external"> Android性能提升之强引用、软引用、弱引用、虚引用使用</a></p>
<h1 id="九、安卓动画"><a href="#九、安卓动画" class="headerlink" title="九、安卓动画:"></a><strong>九、安卓动画:</strong></h1><p><a href="http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html" target="_blank" rel="external">Android动画学习笔记-Android Animation</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （上）</a></p>
<h1 id="十、Dalvik和Art区别？"><a href="#十、Dalvik和Art区别？" class="headerlink" title="十、Dalvik和Art区别？:"></a><strong>十、Dalvik和Art区别？:</strong></h1><p><a href="http://blog.csdn.net/watermusicyes/article/details/50526814" target="_blank" rel="external"> Dalvik和ART运行时环境的区别</a></p>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a><br>QQ：1003077897</p>
<p>安卓面试清单</p>
]]></content>
    
    <summary type="html">
    
      面试记录本
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一款仿快递100的快递类APP  H-Express</title>
    <link href="http://yoursite.com/2017/05/05/%E4%B8%80%E6%AC%BE%E4%BB%BF%E5%BF%AB%E9%80%92100%E7%9A%84%E5%BF%AB%E9%80%92%E7%B1%BBAPP%E4%B9%8BH-Express/"/>
    <id>http://yoursite.com/2017/05/05/一款仿快递100的快递类APP之H-Express/</id>
    <published>2017-05-05T01:10:16.000Z</published>
    <updated>2017-07-08T02:09:55.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H-Express-Android-App"><a href="#H-Express-Android-App" class="headerlink" title="H-Express Android App"></a>H-Express Android App</h1><p><img src="https://img.shields.io/badge/platform-Android-blue.svg" alt="Platform"><img src="https://img.shields.io/badge/debug-1.0.0-orange.svg" alt="Release"><img src="https://img.shields.io/badge/gradle-2.0.0-blue.svg" alt="Gradle"><a href=""><img src="https://img.shields.io/packagist/l/doctrine/orm.svg?style=plastic" alt="Packagist"></a></p>
<p><img src="http://img.blog.csdn.net/20170504170212518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><a href="https://github.com/qht1003077897/H-Express/blob/master/apk/app-debug.apk" target="_blank" rel="external">H-Express  APK</a></p>
<hr>
<p>download这个项目，你可以学到：</p>
<ol>
<li>EventBus</li>
<li>OkHttp</li>
<li>butterknife</li>
<li>Glide图片加载</li>
<li>ZXing二维码扫描</li>
<li>白天/夜间模式切换</li>
<li>第三方QQ登录、分享</li>
<li>安卓爬虫</li>
<li>RecyclerView使用</li>
<li>BaseActivity、BaseFragment、BaseAdapter</li>
<li>LitePal数据库使用</li>
</ol>
<hr>
<ul>
<li><strong>H-Express</strong> is an express delivery tracking app , built on OkHttp、EventBus、LitePal、Glide and ZXing.</li>
<li>H-Express 是一款快递追踪 APP，基于OkHttp、EventBus、LitePal、Glide、RecyclerView、ZXing而构建。</li>
</ul>
<ul>
<li>Clone the Repository: </li>
<li>克隆仓库：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/qht1003077897/H-Express.git</div></pre></td></tr></table></figure>
<ul>
<li>Suggestion: It is better for you to update your Android Studio to<br>version 2.0 when you open this project.</li>
<li>建议：运行此项目最好使用 Android Studio2.0 以上版本。</li>
</ul>
<h3 id="To-dos"><a href="#To-dos" class="headerlink" title="To-dos"></a>To-dos</h3><ul>
<li>This project is still in progress. Here are the some features that I<br>will finish in the future. </li>
<li><p>这个项目还在开发当中，下面的条目是我以后的完善计划。</p>
<p>√ 完成客服模块。<br>√ 加入网点地图模式。<br>√ 界面美化、按钮样式统一。<br>√ …..</p>
</li>
</ul>
<h3 id="Help-Me-Improve-This-App"><a href="#Help-Me-Improve-This-App" class="headerlink" title="Help Me Improve This App"></a>Help Me Improve This App</h3><ul>
<li>As you can see at the screenshots, some images in H-Express app are not suitable. So If you want to improve the translation of H-Express, please email me.</li>
</ul>
<ul>
<li>从截图中可以看到，H-Express 并不是很完善，因此如果你有更好的建议或者想帮助我一起完善 H-Express，请 Email 我。</li>
</ul>
<hr>
<p><img src="http://img.blog.csdn.net/20170427215859131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170427220250668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170427220309106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170504170118094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170504170133439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20170504170200690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="2017-05-03"><a href="#2017-05-03" class="headerlink" title="2017-05-03"></a>2017-05-03</h2><ol>
<li>完成“寄快递”部分功能（数据来自快递100 H5 解析，包括网点信息、时效天数）。</li>
<li>完成“添加常用地址”功能。</li>
<li>编写“关于”界面。</li>
</ol>
<hr>
<h2 id="2017-04-27"><a href="#2017-04-27" class="headerlink" title="2017-04-27"></a>2017-04-27</h2><ol>
<li>完成订单模块(包括已完成、已签收、未签收订单查看、编辑、单选、多选、全选、删除功能，包括手工设置订单状态为 已/未 签收)</li>
<li>增加 夜间/白天 主题切换</li>
<li>加入第三方(QQ)登录、退出登录、分享功能</li>
<li>可清除缓存</li>
<li>实时天气温度信息</li>
</ol>
<hr>
<h2 id="2017-04-18"><a href="#2017-04-18" class="headerlink" title="2017-04-18"></a>2017-04-18</h2><ol>
<li>实现订单详情页面</li>
<li>时间轴式订单信息</li>
<li>RecyclerView添加BaseAdapter</li>
<li>添加menu菜单样式</li>
<li>使用litepal数据库存储订单信息</li>
<li>首页添加weelview选择快递公司</li>
</ol>
<hr>
<h2 id="2017-04-14"><a href="#2017-04-14" class="headerlink" title="2017-04-14"></a>2017-04-14</h2><ol>
<li>首页Fragment订单查询输入</li>
<li>订单页面viewpage+fragment </li>
</ol>
<hr>
<h2 id="2017-04-11"><a href="#2017-04-11" class="headerlink" title="2017-04-11"></a>2017-04-11</h2><ol>
<li>BaseFragment </li>
<li>微信底部菜单栏  </li>
<li>无数据情况下的EmptyView </li>
</ol>
<hr>
<h2 id="2017-04-05"><a href="#2017-04-05" class="headerlink" title="2017-04-05"></a>2017-04-05</h2><ol>
<li>OkHttp 3.3.1(引用鸿洋的一个OkhttpUtil) </li>
<li>EventBus 3.0  </li>
<li>Json解析 </li>
<li>ButterKnife8.5.1</li>
</ol>
<hr>
<h2 id="2017-03-26"><a href="#2017-03-26" class="headerlink" title="2017-03-26"></a>2017-03-26</h2><ol>
<li>透明状态栏 </li>
<li>生命周期监控 </li>
<li>顶部统一的ToolBar</li>
</ol>
<hr>
<h2 id="尊重原创，请勿用作商业用途"><a href="#尊重原创，请勿用作商业用途" class="headerlink" title=" 尊重原创，请勿用作商业用途."></a> 尊重原创，请勿用作商业用途.</h2><h2 id="License"><a href="#License" class="headerlink" title=" License"></a> License</h2><pre><code> MIT License

Copyright (c) 2016-2018  qht1003077897

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      https://github.com/qht1003077897/H-Express
    
    </summary>
    
      <category term="开源" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="开源" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>APP构建之路问题记录</title>
    <link href="http://yoursite.com/2017/04/27/App%E6%9E%84%E5%BB%BA%E4%B9%8B%E8%B7%AF%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/04/27/App构建之路问题记录/</id>
    <published>2017-04-27T07:31:16.000Z</published>
    <updated>2017-04-27T10:38:30.071Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>-</p>
<h2 id="2017-04-27-━-Fragment-中使用-startActivityforResult-导致-onActivityResult-中的-request-对不上（二维码扫描订单功能）"><a href="#2017-04-27-━-Fragment-中使用-startActivityforResult-导致-onActivityResult-中的-request-对不上（二维码扫描订单功能）" class="headerlink" title="2017-04-27 ━ Fragment 中使用 startActivityforResult() 导致 onActivityResult() 中的 request 对不上（二维码扫描订单功能）"></a>2017-04-27 ━ Fragment 中使用 startActivityforResult() 导致 onActivityResult() 中的 request 对不上（二维码扫描订单功能）</h2><hr>
<p> <strong>- 相关代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">startActivityForResult(intent, ConstantUtil.REQUEST_QR_CODE);</div><div class="line"></div><div class="line">if(requestCode == ConstantUtil.REQUEST_QR_CODE)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>- 情景还原1：</strong></p>
<p>在 Fragment 中执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getActivity().startActivityForResult(intent,Util.REQUEST_QR_CODE);</div></pre></td></tr></table></figure>
<p>跳转新的Activity。</p>
<p>并重写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override    </div><div class="line">public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">       super.onActivityResult(requestCode, resultCode, data);</div><div class="line">       /** 二维码扫描 */</div><div class="line">       if (resultCode == mActivity.RESULT_OK</div><div class="line">               &amp;&amp; requestCode == Util.REQUEST_QR_CODE</div><div class="line">               &amp;&amp; data != null) &#123;</div><div class="line">           String result = data.getStringExtra(&quot;result&quot;);</div><div class="line">       &#125;    &#125;</div></pre></td></tr></table></figure></p>
<p>结果是：</p>
<p>onActivityResult中根本没有接收到消息。</p>
<p>BUT： 在 Fragment 所依附的 Activity 中却接收到了消息</p>
<p> <strong>- 情景还原2：</strong></p>
<p>在 Fragment 中执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivityForResult(intent,Util.REQUEST_QR_CODE);</div></pre></td></tr></table></figure>
<p>跳转新的Activity。</p>
<p>并重写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override    </div><div class="line">public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">       super.onActivityResult(requestCode, resultCode, data);</div><div class="line">       /** 二维码扫描 */</div><div class="line">       if (resultCode == mActivity.RESULT_OK</div><div class="line">               &amp;&amp; requestCode == Util.REQUEST_QR_CODE</div><div class="line">               &amp;&amp; data != null) &#123;</div><div class="line">           String result = data.getStringExtra(&quot;result&quot;);</div><div class="line">       &#125;    &#125;</div></pre></td></tr></table></figure></p>
<p>结果是： </p>
<p>onActivityResult中接收到了消息。<br>在 Fragment 所依附的 Activity 中也接收到了消息</p>
<p>BUT：  在 Fragment 所依附的 Activity 中接收的 requestcode 却不等于 Util.REQUEST_QR_CODE。</p>
<p> <strong>- 错误原因：</strong></p>
<p>具体原因这儿有：<a href="http://blog.csdn.net/ruancoder/article/details/53490500" target="_blank" rel="external">http://blog.csdn.net/ruancoder/article/details/53490500</a></p>
<p>我猜 SDK 这样做的目的是：</p>
<p>跳转请求来自于 Fragment，就让反馈消息给 Fragment。<br>即：<code>startActivityForResult(intent,Util.REQUEST_QR_CODE);</code><br>跳转请求来自于 getActivity()，就让反馈消息给 Activity。<br>即：<code>getActivity().startActivityForResult(intent,Util.REQUEST_QR_CODE);</code></p>
<p> <strong>- 问题解决：</strong>  </p>
<p>在 Fragment 中使用 <strong>情景2</strong> 中的代码即可。</p>
<hr>
<p>-</p>
<h2 id="2017-04-26-━-夜间模式开发中碰到的问题"><a href="#2017-04-26-━-夜间模式开发中碰到的问题" class="headerlink" title="2017-04-26 ━  夜间模式开发中碰到的问题"></a>2017-04-26 ━  夜间模式开发中碰到的问题</h2><hr>
<p> <strong>- 问题1：安卓5.0版本以上 AppTheme 的颜色必须使用 RGB(#FFFFFF) 格式，若使用 ARGB(#FFFFFFFF) 格式,报错。</strong></p>
<p> <strong>- 问题2-问题描述：</strong></p>
<p>在切换夜间模式的时候，不管使用 setTheme() 方法还是使用 V7 包中的 AppCompatDelegate 类，都不免需要重启当前 Activity，造成屏幕闪烁一次，那么怎么做到平滑切换夜间模式呢？</p>
<p> <strong>- 问题解决：</strong>  </p>
<p>查看了资料网上大多数资料都是在切换的时候截图当前屏幕，然后使用一个渐隐动画消失这张图片，以做到平滑过渡。但是我使用 安卓4.4 的联想手机和 安卓6.0 的小米手机测试都不行，还是会闪烁。</p>
<p>所以我采用下面的方式：</p>
<p>使用一个中间 SwitchActivity 加上进入离开动画作为 MainActivity 自启的中介。</p>
<p>具体见代码和 anim 包下的 xml 动画文件。</p>
<hr>
<p>-</p>
<h2 id="2017-04-24-━-recyclerview-包含checkbox-抢夺事件焦点"><a href="#2017-04-24-━-recyclerview-包含checkbox-抢夺事件焦点" class="headerlink" title="2017-04-24 ━ recyclerview 包含checkbox 抢夺事件焦点"></a>2017-04-24 ━ recyclerview 包含checkbox 抢夺事件焦点</h2><hr>
<p> <strong>- 问题描述：</strong></p>
<p> 在 recyclerview 的 item 中包含有 checkbox 控件，recyclerview 设置 OnItemClickListener 不生效。倘若使用 addOnItemTouchListener 方法则 item 的点击事件生效，但是当点击 checkbox 时 OnItemTouchListener 方法也会生效。</p>
<p> 1、recyclerview 设置 OnItemClickListener 无效。<br> 2、checkbox 设置如下：  </p>
<pre><code>android:focusable=&quot;false&quot;
android:focusableInTouchMode=&quot;false&quot; 
</code></pre><p>无效。</p>
<p>3、 根布局设置 </p>
<pre><code>android:descendantFocusability=&quot;blocksDescendants&quot;
</code></pre><p> 无效。</p>
<p> <strong>- 错误原因：</strong></p>
<p>类似于 checkbox 、 button 等对焦点具有高优先级的控件，会抢夺父 View 焦点。</p>
<p> <strong>- 问题解决：</strong>  </p>
<p><strong>暂未解决。</strong><br>-</p>
<p> <strong>- 应急方案：</strong>   </p>
<ol>
<li><p>使用 addOnItemTouchListener 实现 item 的点击事件。 并且在 checkbox 被选择时使用布尔值<br>check=true； 标志当前点击是 checkbox 发出的。如果是 checkbox 发出的则 置 check=false； 且在<br>onItemClick 方法里面不对此次事件做出任何响应。</p>
</li>
<li><p>不使用 recycleview 的 item 点击事件，而是在 item 上面添加一个小箭头，点击小箭头即为点击 item，这样<br>checkbox 的点击事件和小箭头的点击事件则是独立的。</p>
</li>
</ol>
<hr>
<p>-</p>
<h2 id="2017-04-22-━-Litepal-删除数据不成功"><a href="#2017-04-22-━-Litepal-删除数据不成功" class="headerlink" title="2017-04-22 ━ Litepal 删除数据不成功"></a>2017-04-22 ━ Litepal 删除数据不成功</h2><hr>
<p> <strong>- 相关代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@OnClick(R.id.btn_orderall_delete)</div><div class="line">public void onClick() &#123;</div><div class="line">for(int i=0;i&lt;list.size();i++)&#123;</div><div class="line">if(list.get(i).isselect())&#123;</div><div class="line">list.remove(i);</div><div class="line">DataSupport.delete(OrderInfoLitePal.class,i+1);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">LogUtil.e(&quot;&quot;+DataSupport.count(OrderInfoLitePal.class));</div><div class="line">madapter.notifyDataSetChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本来 list 的大小是3，执行 delete 后大小还是3</p>
<p> <strong>- 错误原因：</strong></p>
<p>使用 litepal 删除数据时不能根据 list 的 position 作为 delete 的参数 id 进行删除，因为在数据库中我们知道如果使用自增id的话，删除一条数据，它的id是不会变的。比如1、2、3、4、5个自增id，删除id为3的数据，那么现在表大小为4，id分别为1、2、4、5，可见会跳过3。</p>
<p> <strong>- 问题解决：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@OnClick(R.id.btn_orderall_delete)</div><div class="line">    public void onClick() &#123;</div><div class="line">        for(int i=0;i&lt;list.size();i++)&#123;</div><div class="line">            if(list.get(i).isselect())&#123;</div><div class="line">                int id=list.get(i).getId();</div><div class="line">                list.remove(i);</div><div class="line">                DataSupport.delete(OrderInfoLitePal.class,id);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        LogUtil.e(&quot;&quot;+DataSupport.count(OrderInfoLitePal.class));</div><div class="line">        madapter.notifyDataSetChanged();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们在定义javabean的时候需要自己定义一个 ID 字段，不用设置值，在执行插入操作时litepal会自动为我们的数据插入 ID，然后在删除时使用这个 ID 作为 delete 方法的参数进行删除，成功。</p>
<hr>
<p>-</p>
<h2 id="2017-04-14-━-Gson-解析时使用泛型报错-LinkedTreeMap-相关"><a href="#2017-04-14-━-Gson-解析时使用泛型报错-LinkedTreeMap-相关" class="headerlink" title="2017-04-14 ━ Gson 解析时使用泛型报错 LinkedTreeMap 相关"></a>2017-04-14 ━ Gson 解析时使用泛型报错 LinkedTreeMap 相关</h2><hr>
<p> <strong>相关代码：</strong></p>
<p>gson.fromJson(json, clazz)</p>
<p> <strong>错误日志：</strong></p>
<p>java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.qht.blog2.OtherActivity.orderdetail.data.OrderInfoDetailBean</p>
<p> <strong>现场还原：</strong></p>
<p>在使用 Gson 解析时，我们使用了封装的 JavaBean ，意味着要使用泛型。在解析的时候正常，解析为 LinkedTreeMap 类型，但是在使用 get 方法取值的时候报错 LinkedTreeMap 不能转化为<br> JavaBean。</p>
<p> <strong>问题解决：</strong></p>
<ul>
<li><p>情况1：</p>
<p>若返回类型为 List<t> 类型，我们采用这种方式解析：</t></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 将返回的 List 类型的 Json 字符串解析为 List</div><div class="line">    * @param &lt;T&gt;</div><div class="line">    * @param json</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public static  &lt;T&gt; List&lt;T&gt; jsonToList(String json,Class&lt;T&gt; clazz) &#123;</div><div class="line">       if (TextUtils.isEmpty(json) || null == clazz) &#123;</div><div class="line">           return null;</div><div class="line">       &#125;</div><div class="line">       List&lt;T&gt; list = new ArrayList&lt;T&gt;();</div><div class="line">       JsonArray array = new JsonParser().parse(json).getAsJsonArray();</div><div class="line">       for(final JsonElement elem : array)&#123;</div><div class="line">           list.add(gson.fromJson(elem, clazz));</div><div class="line">       &#125;</div><div class="line">       return list;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>情况2：(我采用的方法二，很明显是很笨的方法，所有希望能找个更好的方法。)</p>
<p>若返回类型为 Model 类型，并且里面包含 list，例如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">public class OrderInfoBean&lt;T&gt; extends  CommBean&#123;</div><div class="line">String message;</div><div class="line">String nu;</div><div class="line">String ischeck;</div><div class="line">String condition;</div><div class="line">String com;</div><div class="line">String status;</div><div class="line">String state;</div><div class="line">private List&lt;T&gt; data;</div></pre></td></tr></table></figure>
<p>  我们先解析为正常 model，然后通过 getdata 方法拿到这个 list ，然后通过下面的方法先转换为 String：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">  public static  &lt;T&gt; String ListTojson(List&lt;T&gt; T) &#123;</div><div class="line">    String jsonStr = gson.toJson(T);</div><div class="line">    return jsonStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再然后通过下面的方法再解析一次，便可以得到正常的 List<t> ,而非 LinkedTreeMap。</t></p>
<hr>
<p>-</p>
<h2 id="2017-04-13-━-Android-Studio-compile时导致重复包"><a href="#2017-04-13-━-Android-Studio-compile时导致重复包" class="headerlink" title="2017-04-13 ━ Android Studio compile时导致重复包"></a>2017-04-13 ━ Android Studio compile时导致重复包</h2><hr>
<p> <strong>- 相关代码：</strong></p>
<p>compile ‘com.android.support:support-v4:24.2.1’<br>compile (‘com.android.support:appcompat-v7:24.2.1’)<br>        {exclude module: ‘support-v4’}</p>
<p> <strong>- 错误日志：</strong></p>
<p>Error converting bytecode to dex: Cause: com.android.dex.DexException:<br>Multiple dex files define Landroid/support/v4/accessibilityservice/<br>AccessibilityServiceInfoCompatIcs;</p>
<p> <strong>- 现场还原：</strong></p>
<p>在我们 compile 导入依赖包的时候某些包也许恰恰依赖了 support-v4 包，然后导致上面的错误，意思是存在多个相同的类   AccessibilityServiceInfoCompatIcs，这就是因为我们的v4包重复了。</p>
<p> <strong>- 问题解决：</strong></p>
<ul>
<li>方法1：</li>
</ul>
<p> <img src="http://img.blog.csdn.net/20170413173559251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170413174340323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170413173702598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>选择 Project，点击 External Libraries，可以看到，我们不止有重复的v4包，还有drawable包也重复了。第一种方法便是</p>
<p><img src="http://img.blog.csdn.net/20170413174603076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在你的 App build 文件中添加 <code>mutiDexEnabled true</code>，支持多Dex文件，但是这样会导致编译过慢，所以我们还需要在你的 APP build 文件的添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    dexOptions &#123;</div><div class="line">        preDexLibraries = false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>增加编译速度。</p>
<ul>
<li>方法2：</li>
</ul>
<p>第二种方法呢，是在出现问题的 compile 包下面添加例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile (&apos;com.android.support:appcompat-v7:24.2.1&apos;)</div><div class="line">            &#123; exclude module: &apos;support-v4&apos; &#125;</div></pre></td></tr></table></figure>
<p>意思是移除这个包所引用的v4包，完了之后 clean 再编译。</p>
<ul>
<li>方法3（特例）:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:support-v4:24.2.1&apos;</div><div class="line">compile (&apos;com.android.support:appcompat-v7:24.2.1&apos;)</div><div class="line">          &#123; exclude module: &apos;support-v4&apos; &#125;</div></pre></td></tr></table></figure>
<p>如上所示，首先在所有的 compile 下面写上  <code>{ exclude module: &#39;support-v4&#39; }</code>这段代码，clean 一下，然后删除刚才的所有 exclude ，再重新引入v4和v7包，并且在v7包下 exclude v4包，再 clean。意思是使用这个v4包代替其他包下的v4包，最后 clean 并且 build。</p>
<hr>
<p>-</p>
<h2 id="2017-04-09-━-EventBus-发布事件不能被接收"><a href="#2017-04-09-━-EventBus-发布事件不能被接收" class="headerlink" title="2017-04-09 ━ EventBus 发布事件不能被接收"></a>2017-04-09 ━ EventBus 发布事件不能被接收</h2><hr>
<p> <strong>- 相关代码：</strong></p>
<pre><code>EventBus.getDefult().register(subscriber);
</code></pre><p> <strong>- 现场还原：</strong></p>
<p>在 fragment 注册 eventbus 时参数为 getactivity，导致 fragment 内部的 onEvent 方法不能接收post 出的事件，而被 activity 接收。</p>
<p> <strong>- 问题解决：</strong></p>
<pre><code>fragment 在注册是参数填写 this，而不是 getActivity。
</code></pre><p>如果参数为 getActivity，表示注册事件到依附的 activity。在 post 事件的时候而导致父类 activity 或者所依附的 activity 截获 post 事件，引起本 fragment 不能正常接收。</p>
<p>所以注册时参数为当前类，或者直接填写 this，不论任何类，首先保证在本类生效。</p>
]]></content>
    
    <summary type="html">
    
      对于踩过的坑记录下来，实时更新
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(四)</title>
    <link href="http://yoursite.com/2017/04/25/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%89%E5%8D%93%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%B8%A6%E4%BD%A0%E5%81%9A%E8%87%AA%E5%B7%B1%E7%9A%84APP(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2017/04/25/手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(四)/</id>
    <published>2017-04-25T01:10:16.000Z</published>
    <updated>2017-04-25T01:43:48.153Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看上一篇文章：<a href="http://blog.csdn.net/u012534831/article/details/70040106" target="_blank" rel="external">手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(三)</a></p>
<p>继上一篇我们的开发，包含</p>
<ul>
<li>BaseFragment  </li>
<li>精美的仿微信底部菜单栏  </li>
<li>网络请求失败时如何显示空View</li>
</ul>
<p>那么，这一篇，我准备完成：</p>
<ul>
<li>精美的订单追踪页面  </li>
<li>fragment+viewpage实现完整订单查看模块</li>
<li>baseAdapter+下拉刷新</li>
<li>litepal数据库操作</li>
</ul>
<p>其实到上一篇为止，我们的快速开发框架已经基本完成了。所以呢，接下来我准备在此基础上开发我们的一款APP—–<strong>玩快递</strong></p>
<p>上面所说的准备完成的4部分其实我已经做完了，代码在git上，所以这儿我只是带大家看一下，就不细说。</p>
<p><strong>1、开门见山，看下什么是精美的订单追踪页面？</strong></p>
<p><img src="http://img.blog.csdn.net/20170425094428881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如上：我们使用 <strong>recycleview</strong> 来实现。</p>
<p>首先是一个自定义View，这个自定义 View 包含三部分，</p>
<ul>
<li>beginline</li>
<li>mark</li>
<li>endline</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170424211159691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>代码在这里：<br><a href="https://github.com/qht1003077897/AppFrame/blob/master/app/src/main/java/com/qht/blog2/View/TimeLineMarkerView.java" target="_blank" rel="external">https://github.com/qht1003077897/AppFrame/blob/master/app/src/main/java/com/qht/blog2/View/TimeLineMarkerView.java</a></p>
<p>使用了自定义属性，以便在 adapter 中设置这三个位置的 drawable，比如图中的红点</p>
<ul>
<li>如果已经签收，setbeginline(null); setmark(color.red);</li>
<li>如果在途中，则不用设置，使用 xml 中定义的即可。</li>
<li>如果是第一条信息，即为开始派件，则 setendline(null);</li>
</ul>
<p>然后 View 的左边是订单时间，右边是具体信息，下面加了一条 height=1px的 view 作为分割线，并且设置 recycleview 的分割线为 null。</p>
<p>接下来看下我们 recycleview 所使用的 Adapter，考虑到 recycleview 的通用性，以及我们的订单页面使用的也是 recycleview，所以我们需要一个 BaseAdapter。</p>
<p>在 github上找了一个，算是比较强大的，并且作者一直在维护：<a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="external">RecycleViewBaseAdapter</a></p>
<p>看下我们是怎么用的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by QHT on 2017-04-12.</div><div class="line"> * 订单详情页面</div><div class="line"> */</div><div class="line">public class OrderDetail_RV_Adapter extends BaseQuickAdapter&lt;OrderInfoDetailBean,BaseViewHolder&gt; &#123;</div><div class="line"></div><div class="line">    private Context context;</div><div class="line">    private TimeLineMarkerView timelineView;</div><div class="line">    private String state;</div><div class="line"></div><div class="line"></div><div class="line">    public OrderDetail_RV_Adapter(List&lt;OrderInfoDetailBean&gt; list,String state,Context context) &#123;</div><div class="line">        super(R.layout.activity_orderdetail_rv_item, list);</div><div class="line">        this.context=context;</div><div class="line">        this.state=state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void convert(BaseViewHolder helper, OrderInfoDetailBean item) &#123;</div><div class="line">        if(timelineView==null ) &#123;</div><div class="line">            timelineView = (TimeLineMarkerView) (helper.getView(R.id.tv_rv_activity_orderdetail_timelineview));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(helper.getItemViewType()==OrderSite.BEGIN)&#123;</div><div class="line">            timelineView.setBeginLine(null);</div><div class="line">            helper.setTextColor(R.id.tv_rv_activity_orderdetail_time,context.getResources().getColor(R.color.red));</div><div class="line">            helper.setTextColor(R.id.tv_rv_activity_orderdetail_content,context.getResources().getColor(R.color.red));</div><div class="line">            timelineView.setMarkerDrawable(context.getResources().getDrawable(R.drawable.timeline_bg_red));</div><div class="line">        &#125; else if(helper.getItemViewType()==OrderSite.END)&#123;</div><div class="line">            timelineView.setEndLine(null);</div><div class="line">        &#125;</div><div class="line">            helper.setText(R.id.tv_rv_activity_orderdetail_content, item.getContext());</div><div class="line">            //分两行显示</div><div class="line">            helper.setText(R.id.tv_rv_activity_orderdetail_time,</div><div class="line">                item.getTime().toString().substring(0,10)+&quot;\n&quot;+</div><div class="line">                item.getTime().toString().substring(10));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public int getItemViewType(int position) &#123;</div><div class="line">                if(position==0 &amp;&amp; state.equals(&quot;3&quot;))&#123;</div><div class="line">                    return OrderSite.BEGIN;</div><div class="line">                &#125;else if(position==getItemCount()-1)&#123;</div><div class="line">                    return OrderSite.END;</div><div class="line">                &#125;</div><div class="line">                return  super.getItemViewType(position);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在 getItemViewType 类里面判断 item 的类型，返回不同的 int 值：</p>
<ul>
<li>OrderSite.BEGIN  代表订单已经签收。</li>
<li>OrderSite.END     代表订单开始派发。</li>
</ul>
<p>然后在convert 方法中对 viewtype 进行判断，若为签收状态，则不显示 beginline，且 mark 为红色标示；若为派单状态，则 endline 不显示。</p>
<hr>
<p> <strong>2、接下来我们需要花很多时间看这个地方–订单列表  ↓ </strong>   </p>
<p><img src="http://img.blog.csdn.net/20170425094449350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>看图，在这个页面中，包含了以下几个要点：</p>
<ul>
<li>recycleview 的下拉刷新  </li>
<li>recycleview 的右移动画  </li>
<li>Activity 和 Fragment 积极通信</li>
<li>单选、多选、全选删除动作</li>
<li>litepal 增删改查</li>
</ul>
<p>你有没有注意到，在上个页面，我们的右下角有个浮动按钮，点击是这样的效果：</p>
<p><img src="http://img.blog.csdn.net/20170424220605933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>噢，是将这个订单标记为已签收或者未签收状态，所以，我们还用到了数据库。</p>
<p><img src="http://img.blog.csdn.net/20170424220903155?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>头大，但是也得看下去！</p>
<p>首先，我们有这样一个model：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class OrderInfoLitePal extends DataSupport &#123;</div><div class="line"></div><div class="line"></div><div class="line">    int     id;</div><div class="line">    String  nu;</div><div class="line">    String  com;</div><div class="line">    String  state;</div><div class="line">    String  time;</div><div class="line">    boolean isselect;</div><div class="line"></div><div class="line">    public int getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(int id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ............................</div></pre></td></tr></table></figure>
<p>isselect 字段的目的是为了解决 checkbox 状态错乱的问题。</p>
<p>extends DataSupport 是 litepal 所需，id 是每条数据的 Id,后面会方便删除。</p>
<p> <strong>1. 先来看下拉刷新：</strong></p>
<p>下拉刷新我们用到了这个库 <a href="https://github.com/baoyongzhang/android-PullRefreshLayout" target="_blank" rel="external">pullrefreshlayout</a></p>
<p>用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">swipeRefreshLayoutOrderall.setOnRefreshListener(new PullRefreshLayout.OnRefreshListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onRefresh() &#123;</div><div class="line">                swipeRefreshLayoutOrderall.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        QueryData();</div><div class="line">                        notifydata();</div><div class="line">                        swipeRefreshLayoutOrderall.setRefreshing(false);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p> <strong>2. 衔接上，下面是数据库查询操作 ：</strong></p>
<p>使用 findAll 方法查一遍数据库，更新 list，再刷新视图即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 避免调用notify失败</div><div class="line">     */</div><div class="line">    public void QueryData() &#123;</div><div class="line">      list.clear();</div><div class="line">      List&lt;OrderInfoLitePal&gt; lists=new ArrayList&lt;OrderInfoLitePal&gt;();</div><div class="line">      lists= DataSupport.findAll(OrderInfoLitePal.class);</div><div class="line">      list.addAll(lists);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>为了避免调用 notifyDataSetChanged 失败，采用上面的办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lists= DataSupport.findAll(OrderInfoLitePal.class);</div></pre></td></tr></table></figure>
<p>这句代码即为查询数据库中 表名为 <strong>OrderInfoLitePal</strong> 的所有数据。</p>
<p>因为是全部订单，所以使用 findAll 。<br>如果是已签收订单（state为3代表已签收，其余状态各有意思）： 则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lists=DataSupport.where(&quot;state=?&quot;,&quot;3&quot;).find(OrderInfoLitePal.class);</div></pre></td></tr></table></figure>
<p>如果是未签收（state不等于3则为未签收），则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lists=DataSupport.where(&quot;state!=?&quot;,&quot;3&quot;).find(OrderInfoLitePal.class);</div></pre></td></tr></table></figure>
<p>3个页面非业务功能一致，所有这儿只说所有订单页面。</p>
<p> <strong>3. 使用 EventBus 进行通信：</strong></p>
<p>因为我们的结构是下面这样的：</p>
<p><img src="http://img.blog.csdn.net/20170424224416891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>toolbar 位于 MainActivity 上，如果点击 toolbar ，需要 AllOrderFragment做出动作，很明显我们需要使用 EventBus，并且还需要定制我们的 Event。</p>
<p>如果在上图中加上 EventBus ，则变成这样：</p>
<p><img src="http://img.blog.csdn.net/20170424230351342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在 AllOrder 中我们接受一个 OrderEvent,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class OrderEvent extends Event &#123;</div><div class="line">    public int position;</div><div class="line">    public String from;</div><div class="line">    public  boolean needclose;</div><div class="line">    public  boolean needselect;</div><div class="line"></div><div class="line">    public OrderEvent(boolean needclose,boolean needselect, String from, int position, Object source) &#123;</div><div class="line">        super(source);</div><div class="line">        this.needclose=needclose;</div><div class="line">        this.needselect=needselect;</div><div class="line">        this.from=from;</div><div class="line">        this.position=position;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>position 表示是哪个 fragment 。<br>from 代表这条消息来自哪儿。<br>needclose 代表 Recycleview 的 Item 右移动画是否需要关闭。<br>needselet  代表 checkbox 是否需要被选择。</p>
<p>在 OnEvent 方法中 总共接受4种类型的消息</p>
<ul>
<li><p>第一种消息来自 MainActivity，代表点击了 toolbar 上面的 编辑/取消 按钮。</p>
</li>
<li><p>第二种消息来自 FragmentSecond，表示当切换 fragment 时，关闭上个 fragment 的右移动画 ，并且置select 字段 false。</p>
</li>
<li><p>第三种消息来自 MainActivity，表示点击了 全选/取消全选 按钮，并且置 select 字段 true/false。</p>
</li>
<li><p>第四种消息来自 MainActivity，表示因为底部 fragment 切换需要关闭 item 的右移动画，并且置 select 字段false；</p>
</li>
</ul>
<p>比如说，我们点击了全选按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case R.id.toolbar_sub2title:</div><div class="line">         if (&quot;全选&quot;.equals(getSub2Title().getText().toString())) &#123;</div><div class="line">                getSub2Title().setText(&quot;取消全选&quot;);</div><div class="line">               // To:FragmentOrder_***.onEvent()</div><div class="line">               // false:不需要关闭动画</div><div class="line">               // true: 需要选择</div><div class="line">               // MainActivity_Allselect: 发送自 MainActivity</div><div class="line">               // 参数-1无意义</div><div class="line">               EventBusUtil.postSync(new       OrderEvent(false,true,&quot;MainActivity_Allselect&quot;, -1, this));</div><div class="line">      &#125; </div><div class="line">    else if (&quot;取消全选&quot;.equals(getSub2Title().getText().toString())) &#123;</div><div class="line">               getSub2Title().setText(&quot;全选&quot;);</div><div class="line">               // To:FragmentOrder_Signed.onEvent()</div><div class="line">               EventBusUtil.postSync(new OrderEvent(false,false, &quot;MainActivity_Allselect&quot;, -1, this));</div><div class="line">                &#125;</div><div class="line">                break;</div></pre></td></tr></table></figure>
<p>当然，我们在 viewpage 切换的时候需要关闭上个 fragment 的右移动画和checkbox 的被选效果，则这样就可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">      public void onPageSelected(int position) &#123;</div><div class="line">      </div><div class="line">          lastViewPageIndex=viewPagePosition;</div><div class="line">          viewPagePosition=position;</div><div class="line">          // To:FragmentOrder_Signed.onEvent()  切换，则恢复动画</div><div class="line">          EventBusUtil.postSync(new OrderEvent(true,false,&quot;FragmentSecond&quot;,lastViewPageIndex,this));</div><div class="line">          // To:MainActivity.onEvent() 切换，则还原编辑字样</div><div class="line">          EventBusUtil.postSync(new OrderEvent(true,false,&quot;FragmentSecond&quot;,-1,this));</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>position 发挥作用，表示上个 fragment 的位置，以明确到底是哪个 fragment接收。</p>
<p> <strong>4. 最后看一下单选、多选、全选，以及删除是怎么做的：</strong></p>
<ul>
<li>单选</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.get(response.position).setIsselect(response.checked);</div></pre></td></tr></table></figure>
<p>   设置 isselect 字段为 true 即可；</p>
<ul>
<li><p>多选、全选同理。</p>
</li>
<li><p>删除</p>
</li>
</ul>
<p>最后删除的时候，我们需要遍历 list，找到 isselect字段为 true 的数据，从list 中移除，且调用 notifyItemRemoved 方法更新列表视图，最后从数据库中根据我们 model 中的 id 字段删除这条数据即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@OnClick(R.id.btn_orderall_delete)</div><div class="line">    public void onClick() &#123;</div><div class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</div><div class="line">            if (list.get(i).isselect()) &#123;</div><div class="line">                int id = list.get(i).getId();</div><div class="line">                list.remove(i);</div><div class="line">                madapter.notifyItemRemoved(i);</div><div class="line">                DataSupport.delete(OrderInfoLitePal.class, id);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这篇就到这儿了，代码在 github 上。</p>
<hr>
<p>下一篇，我们来完成个人中心模块，也许包括：</p>
<ul>
<li>侧滑抽屉布局</li>
<li>第三方登录</li>
<li>第三方分享</li>
</ul>
<p>我的QQ: 1003077897<br>我的csdn：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>我的github：<a href="https://github.com/qht1003077897/AppFrame" target="_blank" rel="external">https://github.com/qht1003077897/AppFrame</a><br>我的个人博客：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a></p>
<p>欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      博客出自：http://blog.csdn.net/u012534831
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="手把手" scheme="http://yoursite.com/tags/%E6%89%8B%E6%8A%8A%E6%89%8B/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(三)</title>
    <link href="http://yoursite.com/2017/04/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%89%E5%8D%93%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%B8%A6%E4%BD%A0%E5%81%9A%E8%87%AA%E5%B7%B1%E7%9A%84APP(%E4%B8%89)/"/>
    <id>http://yoursite.com/2017/04/11/手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(三)/</id>
    <published>2017-04-11T01:10:16.000Z</published>
    <updated>2017-04-11T01:08:53.807Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看上一篇文章：<a href="http://blog.csdn.net/u012534831/article/details/69363039" target="_blank" rel="external">手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(二)</a></p>
<p>继上一篇我们的进一步封装，包含</p>
<ul>
<li>OkhttpRequest </li>
<li>EventBus  </li>
<li>Json解析，基类数据封装 </li>
<li>ButterKnife</li>
</ul>
<p>那么，这一篇，我准备加入：</p>
<ul>
<li>BaseFragment  </li>
<li>精美的仿微信底部菜单栏  </li>
<li>网络请求失败时如何显示空View</li>
</ul>
<p>继续来完善我们的快速开发框架。</p>
<p><strong>1、开门见山，看下BaseFragment都做了些什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by QHT on 2017-04-08.</div><div class="line"> */</div><div class="line">public abstract class BaseFragment extends Fragment</div><div class="line">&#123;</div><div class="line">    /**</div><div class="line">     * 依附的activity</div><div class="line">     */</div><div class="line">    protected FragmentActivity mActivity;</div><div class="line">    /**</div><div class="line">     * 根view</div><div class="line">     */</div><div class="line">    protected View mRootView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @Nullable</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,</div><div class="line">                             @Nullable Bundle savedInstanceState)</div><div class="line">    &#123;</div><div class="line">        if (getContentViewId() != 0) &#123;</div><div class="line">            mRootView= inflater.inflate(getContentViewId(), null);</div><div class="line">        &#125; else &#123;</div><div class="line">            mRootView= super.onCreateView(inflater, container, savedInstanceState);</div><div class="line">        &#125;</div><div class="line">        ButterKnife.bind(this, mRootView);</div><div class="line">        LogUtil.e(this.getClass().getName()+&quot;---&gt;onCreateView&quot;);</div><div class="line">        initData(getArguments());</div><div class="line">        return mRootView;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onAttach(Context context)</div><div class="line">    &#123;</div><div class="line">        super.onAttach(context);</div><div class="line">        mActivity = getActivity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置根布局资源id</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public abstract int getContentViewId();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化数据</div><div class="line">     * @param arguments 接收到的从其他地方传递过来的参数</div><div class="line">     */</div><div class="line">    protected void initData(Bundle arguments)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        LogUtil.e(this.getClass().getName()+&quot;---&gt;onResume&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        LogUtil.e(this.getClass().getName()+&quot;---&gt;onStop&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        LogUtil.e(this.getClass().getName()+&quot;---&gt;onDestroy&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，做了一些初始化操作。我们的子Fragment只需要继承并重写2个方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class FragmentSecond extends BaseFragment &#123;</div><div class="line"></div><div class="line">  @Override</div><div class="line">    public int getContentViewId() &#123;</div><div class="line">        return R.layout.fragment_second;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void initData(Bundle arguments) &#123;</div><div class="line">        super.initData(arguments);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  因为暂时我们没有用到viewpage，所以不需要懒加载，等下面用到了的时候再加进去。</p>
<p> <strong>2、接下来看看我们的仿微信底部菜单栏是怎么做的？</strong><br>MainActivity的布局呢，就是上面一个toolbar，中间一个Linearlayout用来显示Fragment，下面一个Ralativelayout容纳4个按钮</p>
<p>首先，初始化我们的Fragment状态，第一个fragment为默认加载的Fragment</p>
<p><img src="http://img.blog.csdn.net/20170410224639063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * 初始化底部标签</div><div class="line">     */</div><div class="line">    private void initTab() &#123;</div><div class="line">        if (oneFragment == null) &#123;</div><div class="line">        </div><div class="line">        /** 默认加载第一个Fragment*/</div><div class="line">            oneFragment = new FragmentFrist();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!oneFragment.isAdded()) &#123;</div><div class="line">        </div><div class="line">       /** 如果第一个未被添加，则添加到管理器中*/</div><div class="line">            getSupportFragmentManager().beginTransaction()</div><div class="line">                    .add(R.id.content_layout, oneFragment).commit();</div><div class="line"></div><div class="line">       /** 记录当前Fragment*/</div><div class="line">            currentFragment = oneFragment;</div><div class="line">            </div><div class="line">       /** 设置图片文本的变化*/  </div><div class="line">llBottomIvOne.setImageResource(R.mipmap.bottom_home_click);</div><div class="line">llBottomTvOne.setTextColor(getResources()</div><div class="line">                    .getColor(R.color.bottom_click));</div><div class="line">            llBottomIvTwo.setImageResource(R.mipmap.bottom_notice_normal);</div><div class="line">llbottomTvTwo.setTextColor(getResources().getColor(</div><div class="line">                    R.color.bottom_normal));</div><div class="line">           llBottomIvThree.setImageResource(R.mipmap.bottom_bill_normal);</div><div class="line">llBottomTvThree.setTextColor(getResources().getColor(</div><div class="line">                    R.color.bottom_normal));          </div><div class="line">            llBottomIvFour.setImageResource(R.mipmap.bottom_me_normal);</div><div class="line">llBottomTvFour.setTextColor(getResources().getColor(</div><div class="line">                    R.color.bottom_normal));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>接下来，当我们点击底部每个按钮时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * 点击第一个tab</div><div class="line">     */</div><div class="line">    private void clickTab1Layout() &#123;</div><div class="line">        if (oneFragment == null) &#123;</div><div class="line">            oneFragment = new FragmentFrist();</div><div class="line">        &#125;</div><div class="line">        addOrShowFragment(getSupportFragmentManager().beginTransaction(), oneFragment);</div><div class="line"></div><div class="line">llBottomIvOne.setImageResource(R.mipmap.bottom_home_click);</div><div class="line">llBottomTvOne.setTextColor(getResources()</div><div class="line">                .getColor(R.color.bottom_click));</div><div class="line">        llBottomIvTwo.setImageResource(R.mipmap.bottom_notice_normal);</div><div class="line">llbottomTvTwo.setTextColor(getResources().getColor(</div><div class="line">                R.color.bottom_normal));</div><div class="line"></div><div class="line">        llBottomIvThree.setImageResource(R.mipmap.bottom_bill_normal);</div><div class="line">llBottomTvThree.setTextColor(getResources().getColor(</div><div class="line">                R.color.bottom_normal));</div><div class="line"></div><div class="line">        llBottomIvFour.setImageResource(R.mipmap.bottom_me_normal);</div><div class="line">llBottomTvFour.setTextColor(getResources().getColor(</div><div class="line">                R.color.bottom_normal));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法用来判断到底是add还是show/hide 我们的Fragment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 添加或者显示碎片</div><div class="line">     *</div><div class="line">     * @param transaction</div><div class="line">     * @param fragment</div><div class="line">     */</div><div class="line">    private void addOrShowFragment(FragmentTransaction transaction,</div><div class="line">                                   Fragment fragment) &#123;</div><div class="line">        if (currentFragment == fragment)</div><div class="line">            return;</div><div class="line">        if (!fragment.isAdded()) &#123; </div><div class="line">        </div><div class="line">        // 如果当前fragment未被添加，则添加到Fragment管理器中</div><div class="line">            transaction.hide(currentFragment)</div><div class="line">                    .add(R.id.content_layout,        </div><div class="line">                    fragment).commit();</div><div class="line">           &#125; else &#123;</div><div class="line">           </div><div class="line">        // 如果当前fragment已被添加，则显示即可</div><div class="line">transaction.hide(currentFragment).show(fragment).commit();</div><div class="line">        &#125;</div><div class="line">        currentFragment = fragment;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p> <strong>3、再来看看我们的空View是怎么实现的呢？</strong></p>
<p>在使用listview时我们见过 setEmptyView() 方法(内部实现原理也是通过 Visible 去控制显示的)，但是其他的 view 却没有吧，因此我们实现一个自己的空 View，在什么时候都可以使用。<br><img src="http://img.blog.csdn.net/20170410233043172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">public class EmptyViewLayout extends RelativeLayout &#123;</div><div class="line">    private ImageView failure;//加载失败的图片</div><div class="line">    private View bindView;// 绑定的View，即要显示的View</div><div class="line">    private Button loading_btn;//重试按钮</div><div class="line">    public EmptyViewLayout(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initView(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public EmptyViewLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        initView(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView(Context context) &#123;</div><div class="line">       </div><div class="line">        View view =              LayoutInflater.from(context).inflate(R.layout.empty_view,null);</div><div class="line">        failure = (ImageView)view.findViewById(R.id.loading_failure);</div><div class="line">        loading_btn= (Button) view.findViewById(R.id.loading_btn);</div><div class="line">        </div><div class="line">        //设置View参数</div><div class="line">        LinearLayout.LayoutParams param = new LinearLayout.LayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,</div><div class="line">       </div><div class="line">        //最后添加进ViewGroup</div><div class="line">        addView(view, param);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *正在加载中</div><div class="line">     */</div><div class="line">    public void Loading() &#123;</div><div class="line">        setVisibility(View.VISIBLE);</div><div class="line">        if (bindView != null) &#123;</div><div class="line">            failure.setVisibility(View.GONE);</div><div class="line">            loading_btn.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     *加载成功</div><div class="line">     */</div><div class="line">    public void succees() &#123;</div><div class="line">        setVisibility(View.GONE);</div><div class="line">        if (bindView != null) &#123;</div><div class="line">            bindView.setVisibility(View.VISIBLE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     *加载失败</div><div class="line">     */</div><div class="line">    public void failure() &#123;</div><div class="line">        setVisibility(View.VISIBLE);</div><div class="line">        if (bindView != null) &#123;</div><div class="line">            failure.setVisibility(View.VISIBLE);</div><div class="line">            bindView.setVisibility(View.GONE);</div><div class="line">            loading_btn.setVisibility(View.VISIBLE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 绑定加载 的view</div><div class="line">    public void bindView(View view) &#123;</div><div class="line">        this.bindView = view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 利用反射机制，响应对方需要响应的方法</div><div class="line">     */</div><div class="line">    public void buttonClick(final Object base, final String method) &#123;</div><div class="line">        loading_btn.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                try &#123;</div><div class="line">                  Method m=base.getClass().getDeclaredMethod(method);</div><div class="line">                         m.setAccessible(true);</div><div class="line">                         m.invoke(base, null);</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在布局和Activity中我们这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  /**</div><div class="line">   *布局中</div><div class="line">   */</div><div class="line">&lt;com.qht.blog2.View.EmptyViewLayout</div><div class="line">       android:id=&quot;@+id/emptyView&quot;</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;</div><div class="line">       android:layout_below=&quot;@+id/toolbar&quot;/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *Activity中</div><div class="line"> */</div><div class="line"> </div><div class="line"> // 绑定要显示的View</div><div class="line"> emptyView.bindView(content);</div><div class="line"> </div><div class="line"> // 注册点击事件，加载失败后点击重试执行onload方法</div><div class="line"> emptyView.buttonClick(this, &quot;onClick&quot;);</div><div class="line"> </div><div class="line"> 在我们的onResponse中执行 emptyView.succees();方法</div><div class="line"> 在我们的onError中执行 emptyView.succees();方法</div><div class="line"> 在我们的onBefore中执行 emptyView.Loading();方法</div></pre></td></tr></table></figure>
<p>原理就是利用View的Visible和Gone去控制显示哪个View。</p>
<hr>
<p>下一篇，我准备开始实现功能了：<br>(因为我们刚开始选用的接口为快递100的，所以功能上考虑为一款快递查询APP)</p>
<ul>
<li>Fragment 和 ViewPage 结合实现顶部标签切换  </li>
<li>RecycleView 实现精美的订单追踪页面</li>
</ul>
<p>我的QQ: 1003077897<br>我的csdn：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>我的github：<a href="https://github.com/qht1003077897/AppFrame" target="_blank" rel="external">https://github.com/qht1003077897/AppFrame</a><br>我的个人博客：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a></p>
<p>欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      博客出自：http://blog.csdn.net/u012534831
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="手把手" scheme="http://yoursite.com/tags/%E6%89%8B%E6%8A%8A%E6%89%8B/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(二)</title>
    <link href="http://yoursite.com/2017/04/05/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%89%E5%8D%93%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%B8%A6%E4%BD%A0%E5%81%9A%E8%87%AA%E5%B7%B1%E7%9A%84APP(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2017/04/05/手把手教你如何搭建一个自己的安卓快速开发框架之带你做自己的APP(二)/</id>
    <published>2017-04-05T14:10:16.000Z</published>
    <updated>2017-04-10T04:22:31.920Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>####<a href="https://qht1003077897.github.io/2017/03/26/BaseActivity/" target="_blank" rel="external">点击查看上一篇文章：手把手教你如何搭建一个自己的安卓快速开发框架之BaseActivity(一)</a></p>
<p>继上一篇我实现了基本的BaseActivity，包含</p>
<blockquote>
<ul>
<li>ToolBar </li>
<li>透明状态栏</li>
<li>生命周期监控</li>
</ul>
</blockquote>
<p>那么，这一篇，我准备引入：</p>
<blockquote>
<ul>
<li>OkHttp 3.3.1(引用鸿洋的一个OkhttpUtil)</li>
<li>EventBus 3.0</li>
<li>Json解析 </li>
<li>ButterKnife8.5.1 </li>
</ul>
</blockquote>
<p> 来完善我们的快速开发框架。</p>
<p>   上次本来说这篇引入RXJava+retrofit，然后再引入MVP，但是突然发现过渡是不是有点太突然。<br>   因此我准备循序渐进，慢慢深入，所以这次我们先用OKhttp+EventBus，去实现一次网络请求并完成界面异步更新。</p>
<p><img src="http://img.blog.csdn.net/20170331140915773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>####<strong>1、首先第一：明确我们服务返回的JSON数据格式：</strong><br>   我们暂且称为<strong>BaseData</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">      &#123;</div><div class="line">    &quot;message&quot;: &quot;ok&quot;,</div><div class="line">    &quot;nu&quot;: &quot;7700008953907&quot;,</div><div class="line">    &quot;ischeck&quot;: &quot;1&quot;,</div><div class="line">    &quot;condition&quot;: &quot;F00&quot;,</div><div class="line">    &quot;com&quot;: &quot;yunda&quot;,</div><div class="line">    &quot;status&quot;: &quot;200&quot;,</div><div class="line">    &quot;state&quot;: &quot;3&quot;,</div><div class="line">    &quot;data&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;time&quot;: &quot;2017-02-14 19:14:27&quot;,</div><div class="line">            &quot;ftime&quot;: &quot;2017-02-14 19:14:27&quot;,</div><div class="line">            &quot;context&quot;: &quot;[陕西西安东郊区兴庆公园公司理工大分部]快件已被 已签收 签收&quot;,</div><div class="line">            &quot;location&quot;: &quot;陕西西安东郊区兴庆公园公司理工大分部&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;time&quot;: &quot;2017-02-12 23:26:15&quot;,</div><div class="line">            &quot;ftime&quot;: &quot;2017-02-12 23:26:15&quot;,</div><div class="line">            &quot;context&quot;: &quot;[上海分拨中心]进行装车扫描，即将发往：陕西西安分拨中心&quot;,</div><div class="line">            &quot;location&quot;: &quot;上海分拨中心&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;time&quot;: &quot;2017-02-12 23:21:52&quot;,</div><div class="line">            &quot;ftime&quot;: &quot;2017-02-12 23:21:52&quot;,</div><div class="line">            &quot;context&quot;: &quot;[上海分拨中心]在分拨中心进行称重扫描&quot;,</div><div class="line">            &quot;location&quot;: &quot;上海分拨中心&quot;</div><div class="line">        &#125;,</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####<strong>2、第二：我们有一个get请求的URL:</strong><br>  <a href="http://www.kuaidi100.com/query" target="_blank" rel="external">http://www.kuaidi100.com/query</a></p>
<p> 有2个参数 type=yunda&amp;postid=7700008953907。</p>
<p>####<strong>3、第三：</strong><br>明确我们希望看到的请求方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Ok_Request.getAsyncData(this, map, UrlUtil.GetKuaiDi, new MyStringCallBack() &#123;</div><div class="line">      </div><div class="line">          @Override</div><div class="line">         public void onResponse(BaseData response, int id) &#123;</div><div class="line">              List&lt;dataModel&gt; resultlist= null;</div><div class="line">              if (response != null) &#123;</div><div class="line">                  resultlist=response.getData();</div><div class="line">                &#125;</div><div class="line">                //EventBus.getDefault().post(resultlist);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>  发送一次get请求，Map里面是我们需要提交的参数。 最后在onResponse方法中得到我们想要的返回结果response，它是通过BaseData做了一层封装的。</p>
<p>####<strong>4、第四：</strong><br>请求结束，通过 EventBus.getDefault().post(resultlist);发送接收到的Json数据以供处理。并且通过dataEvent方法接收数据。ThreadMode.MAIN指定在主线程处理数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Subscribe(threadMode = ThreadMode.MAIN)</div><div class="line">   public void dataEvent(List&lt;dataModel&gt; resultlist) &#123;</div><div class="line">       tv.setText(resultlist.toString());</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>一次流程就这么走完了，但是从哪儿能看出我们这是一个框架呢？</p>
<p> <strong>1. BaseData</strong></p>
<p> 我们明确服务端的数据格式务必统一为BaseData，方便安卓端封装解析方法，直接返回需要的data字段。</p>
<p> <strong>2. getAsyncData</strong></p>
<p> 精简的请求方式，传入参数，URL，CallBack，在onresponse中处理结果即可。</p>
<p> <strong>3. BindView</strong></p>
<p>所有界面省略繁琐的findviewById方法，采用ButterKnife注解生成，包括点击事件。</p>
<hr>
<p>这里，第一和第三比较简单，第一点很必要，因为这直接决定了APP端的封装完整度和简洁度。第三点会用就行。所以，我们下来重点阐述第二点：</p>
<p>本来，OkhttpUtil的用法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">OkHttpUtils</div><div class="line">.get()</div><div class="line">.params(map)</div><div class="line">.tag(mContext)</div><div class="line">.url(url)</div><div class="line">.build()</div><div class="line">.execute(new StringCallback() &#123;</div><div class="line">    @Override</div><div class="line">    public void onError(Call call, Exception e, int id) &#123;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResponse(String response, int id) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>直接放到Activity中有以下几个缺点：</p>
<ul>
<li>每个页面都得写这样一段。</li>
<li>如果一个页面3个请求就得写三个这样的代码段。</li>
<li>突然OKhttpUtil出Bug了需要修改为Volley，难道每个页面都要改吗？！</li>
</ul>
<p>因此，我们需要做个封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by QHT on 2017-04-05.</div><div class="line"> *</div><div class="line"> * GET,PUT等网络操作类</div><div class="line"> */</div><div class="line">public class Ok_Request &#123;</div><div class="line"></div><div class="line">    public static MediaType JSON = MediaType.parse(&quot;application/json;charset=utf-8&quot;);</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * GET方式</div><div class="line">     * 异步get请求</div><div class="line">     * @param url</div><div class="line">     */</div><div class="line"></div><div class="line">    public static void getAsyncData(Context mContext, HashMap&lt;String,String&gt; map,final String url, Callback callback) &#123;</div><div class="line">        OkHttpUtils</div><div class="line">                .get()</div><div class="line">                .params(map)</div><div class="line">                .tag(mContext)</div><div class="line">                .url(url)</div><div class="line">                .build()</div><div class="line">                .execute(callback);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Activity中调用Ok_Request.getAsyncData方法传入一个匿名CallBack即可。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> private static int Ok_count=2;</div><div class="line"></div><div class="line"></div><div class="line"> HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</div><div class="line">       /**</div><div class="line">       * 参数</div><div class="line">       */</div><div class="line">        map.put(&quot;type&quot;, &quot;yunda&quot;);</div><div class="line">        map.put(&quot;postid&quot;, &quot;7700008953907&quot;);</div><div class="line">Ok_Request.getAsyncData(this, map, UrlUtil.GetKuaiDi, new MyStringCallBack() &#123;</div><div class="line">            /**</div><div class="line">             * UI Thread</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void onBefore(Request request, int id) &#123;</div><div class="line">                DialogUtil.showProgressDialog(MainActivity.this, true);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAfter(int id) &#123;</div><div class="line">               --Ok_count;</div><div class="line">                if(Ok_count==0)&#123;</div><div class="line">                    DialogUtil.hideProgressDialog();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(Call call, Exception e, int id) &#123;</div><div class="line">                ToastUtil.showToastLong(e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onResponse(BaseData response, int id) &#123;</div><div class="line">                List&lt;dataModel&gt; resultlist= null;</div><div class="line">                if (response != null) &#123;</div><div class="line">                    resultlist=response.getData();</div><div class="line">                &#125;</div><div class="line">                EventBus.getDefault().post(resultlist);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>共四个回调方法onBefore，onAfter，onResponse，onError。</p>
<ul>
<li>onBefore方法中我们显示一个dialog“加载中…”</li>
<li>onAfter方法中我们dismiss这个dialog</li>
<li>onResponse方法中处理服务端返回的数据 </li>
<li>onError方法中进行异常处理</li>
</ul>
<p>如上，我们已经完成了我们的网络请求。但是，如果我们一个页面不止一次请求呢，有两次呢？我们怎么控制dialog何时隐藏？</p>
<p>这个时候，我们就需要一个计数器Ok_count，在onAfter方法中执行Ok_count减一，并且判断Ok_count是否为0，若为0才允许隐藏dialog。(类似于同步计数器CountDownLatch类)</p>
<hr>
<p>####<strong>说完了请求，下来我们来说说Json</strong></p>
<p>默认情况下，Okhttp返回的数据为Response，那么我们就来一步一步写自己的解析方式：</p>
<p><img src="http://img.blog.csdn.net/20170405214250887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>请求结束之后，数据层首先执行parseNetworkResponse方法(此方法运行在子线程)，返回一个Response，在这里，我们对需要的数据进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by QHT on 2017-04-05.</div><div class="line"> */</div><div class="line">public abstract  class MyStringCallBack  extends Callback&lt;BaseData&gt;&#123;</div><div class="line">    /**</div><div class="line">     * Thread Pool Thread</div><div class="line">     * @param response</div><div class="line">     * @param id</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public BaseData parseNetworkResponse(Response response, int id) throws Exception &#123;</div><div class="line">        String temp=response.body().string();</div><div class="line">        BaseData baseData = GsonUtils.jsonToModel(temp, BaseData.class);</div><div class="line">        return baseData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 解析的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static  &lt;T&gt; T jsonToModel(String json,Class&lt;T&gt; clazz) &#123;</div><div class="line">        if (TextUtils.isEmpty(json) || null == clazz) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            return gson.fromJson(json, clazz);</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            LogUtil.e(&quot;服务端接口json数据格式异常:&quot;+e.getMessage());</div><div class="line">            return null;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过response.body().string()可以拿到返回的String。   </li>
<li>通过我们写好的Json解析类可以将String解析为我们最外层的BaseData。</li>
<li>固定服务端返回数据格式的重要作用就在这儿(统一处理)</li>
</ul>
<p>接下来，回调onResponse方法，参数为我们上面返回的BaseData，onResponse方法最后就变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">public void onResponse(BaseData response, int id) &#123;</div><div class="line">    List&lt;dataModel&gt; resultlist= null;</div><div class="line">    if (response != null) &#123;</div><div class="line">        resultlist=response.getData();</div><div class="line">    &#125;</div><div class="line">    EventBus.getDefault().post(resultlist);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要什么，在BaseData 中取什么就行。</p>
<p>下一篇，我准备开始完善功能了，加入：</p>
<ol>
<li>BaseFrament </li>
<li>微信底部4按钮切换 </li>
<li>登录功能 </li>
<li>快递追踪功能</li>
</ol>
<p>最后，我将代码上传到github上，持续更新，逐渐完善这个简易框架。</p>
<p>我的QQ: <a href="">1003077897</a><br>我的csdn：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>我的github：<a href="https://github.com/qht1003077897/AppFrame" target="_blank" rel="external">https://github.com/qht1003077897/AppFrame</a><br>我的个人博客：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a></p>
<p>欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      博客出自：http://blog.csdn.net/u012534831
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="手把手" scheme="http://yoursite.com/tags/%E6%89%8B%E6%8A%8A%E6%89%8B/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何搭建一个自己的安卓快速开发框架之BaseActivity(一)</title>
    <link href="http://yoursite.com/2017/03/26/BaseActivity/"/>
    <id>http://yoursite.com/2017/03/26/BaseActivity/</id>
    <published>2017-03-26T14:00:16.000Z</published>
    <updated>2017-04-10T04:22:42.750Z</updated>
    
    <content type="html"><![CDATA[<p>   继上一篇博客已经好几个月没发布新博客了，中间因为教研室项目原因转手C#几个月，然后又加上各种事情(再加上懒 - -！)就落下了，<strong>并且有好多小伙伴给我留言上一篇播客的问题我都没能解答，在此给各位小伙伴说声抱歉了</strong>。 今天，又重拾安卓，准备慢慢构建一个自己的安卓快速开发框架，算是经验的总结和积累。网上这种东西很多，但是对于很多初学者而言需要的是动手实践，与此同时，不免就有自己 的感想，因此呢，我也动手并分享出来和大家一起学习。</p>
<hr>
<p>为什么我们要构建一个BaseActivity呢，无非因为以下两点：</p>
<ul>
<li>1、避免重复代码</li>
<li>2、统一管理</li>
</ul>
<p>那么OK，我们构建一个自己的BaseActivity首先有什么需求呢？</p>
<ul>
<li>1、透明状态栏</li>
<li>2、生命周期监控     </li>
<li><p>3、顶部统一的ToolBar</p>
<a id="more"></a>
</li>
</ul>
<p>这是一个简单的Base，方便我们其他的Activity直接继承使用。</p>
<p>从上面可以看出，我们有3个需求，那么我们都放到一个BaseActivity就OK了，在这一个Activity写状态栏、toolbar、日志。但是，这样的话我们如果某个Activity不需要toorbar或者状态栏了怎么办呢？是不是又不能继承了。所以，我们可以将这两个功能拆开，写两个Activity，如果不需要其中一个功能，继承另一个就OK了。</p>
<p>经上面分析，我们此刻需要3个Activity，一个SuperActivity，一个StatusActivity,一个ToolBarActivity就OK了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">package com.android.qht.BaseActivity;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import com.android.qht.Util.LogUtil;</div><div class="line"></div><div class="line">public abstract class superActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(getContentViewId());</div><div class="line">        LogUtil.e(&quot;---&gt;onCreate&quot;);</div><div class="line">    &#125;</div><div class="line">    public abstract int getContentViewId();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        LogUtil.e(&quot;---&gt;onStart&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        LogUtil.e(&quot;---&gt;onStop&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onRestart() &#123;</div><div class="line">        super.onRestart();</div><div class="line">        LogUtil.e(&quot;---&gt;onRestart&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onPause()&#123;</div><div class="line">        super.onPause();</div><div class="line">        LogUtil.e(&quot;---&gt;onpause&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        LogUtil.e(&quot;---&gt;onResume&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        LogUtil.e(&quot;---&gt;onDestroy&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">这儿我用了一个日志工具类，先不管。</div><div class="line"></div><div class="line">先看下我们的superActivity</div><div class="line"></div><div class="line">1、重写了所有的生命周期，加上了日志监控</div><div class="line"></div><div class="line">      保证我们实时监控Activity的生命周期，这很必要，并且我们还可以在生命周期中加入butterKnife等的绑定和解绑等操作。</div><div class="line"></div><div class="line">2、重写setContentView()方法，并加入了getContentViewId()抽象方法</div><div class="line"></div><div class="line">	重写这个方法保证每次初始化布局时传入我们子Activity的布局ID，然后这个抽象方法强制子类重写，传入布局ID，SonActivity-&gt;ToolBarActivity-&gt;SuperActivity，这样就保证了我们的每个界面只听从一个布局，而不是掺杂了父类Activity的布局。</div><div class="line">	</div><div class="line">OK，下来再看下我们的statusActivity：</div><div class="line"></div><div class="line">package com.android.qht.BaseActivity;</div><div class="line">import android.app.Activity;</div><div class="line">import android.os.Build;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line">import android.view.WindowManager;</div><div class="line">import android.widget.LinearLayout;</div><div class="line">import com.android.qht.myandroid.R;</div><div class="line"></div><div class="line">public abstract class statusActivity extends superActivity &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private View statusView;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setstatusColor(this, getResources().getColor(R.color.colorPrimary));//和toolbar一个颜色</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置状态栏颜色</div><div class="line">     *</div><div class="line">     * @param activity 需要设置的activity</div><div class="line">     * @param color    状态栏颜色值</div><div class="line">     */</div><div class="line">    public void setstatusColor(Activity activity, int color) &#123;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            // 设置状态栏透明</div><div class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div><div class="line">            // 生成一个状态栏大小的矩形</div><div class="line"></div><div class="line">            // 添加 statusView 到布局中</div><div class="line">            ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</div><div class="line"></div><div class="line">            if (statusView != null) &#123;</div><div class="line">                decorView.removeView(statusView);</div><div class="line">            &#125;</div><div class="line">            statusView = createStatusView(activity, color);</div><div class="line">            decorView.addView(statusView);</div><div class="line">            // 设置根布局的参数</div><div class="line">            ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);</div><div class="line">            rootView.setFitsSystemWindows(true);</div><div class="line">            rootView.setClipToPadding(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 生成一个和状态栏大小相同的矩形条</div><div class="line">     *</div><div class="line">     * @param activity 需要设置的activity</div><div class="line">     * @param color    状态栏颜色值</div><div class="line">     * @return 状态栏矩形条</div><div class="line">     */</div><div class="line">    private View createStatusView(Activity activity, int color) &#123;</div><div class="line">        // 获得状态栏高度</div><div class="line">        int resourceId = activity.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);</div><div class="line">        int statusBarHeight = activity.getResources().getDimensionPixelSize(resourceId);</div><div class="line"></div><div class="line">        // 绘制一个和状态栏一样高的矩形</div><div class="line">        View statusView = new View(activity);</div><div class="line">        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class="line">                statusBarHeight);</div><div class="line">        statusView.setLayoutParams(params);</div><div class="line">        statusView.setBackgroundColor(color);</div><div class="line">        return statusView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 提供remove方法，在不需要状态栏时可以移除</div><div class="line">     */</div><div class="line">    public void removeView(Activity activity) &#123;</div><div class="line">        ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</div><div class="line">        if (statusView != null) &#123;</div><div class="line">            decorView.removeView(statusView);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个Activity中，我们在子类传递的布局上面添加了一个头部状态栏，颜色和ToolBar一样。先别着急，再看一下我们的ToolBarActivity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line">package com.android.qht.BaseActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.v7.widget.Toolbar;</div><div class="line">import android.view.Menu;</div><div class="line">import android.view.MenuItem;</div><div class="line">import android.view.View;</div><div class="line">import android.widget.TextView;</div><div class="line">import com.android.qht.Util.ToastUtil;</div><div class="line">import com.android.qht.myandroid.R;</div><div class="line"></div><div class="line">/**</div><div class="line"> * ToolBar Activity.</div><div class="line"> */</div><div class="line">public abstract class ToolBarActivity extends statusActivity &#123;</div><div class="line">    private TextView mToolbarTitle;</div><div class="line">    private TextView mToolbarSubTitle;</div><div class="line">    private Toolbar mToolbar;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        mToolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">         /*</div><div class="line">          toolbar.setLogo(R.mipmap.ic_launcher);</div><div class="line">          toolbar.setTitle(&quot;Title&quot;);</div><div class="line">          toolbar.setSubtitle(&quot;Sub Title&quot;);</div><div class="line">          */</div><div class="line">        mToolbarTitle = (TextView) findViewById(R.id.toolbar_title);</div><div class="line">        mToolbarSubTitle = (TextView) findViewById(R.id.toolbar_subtitle);</div><div class="line">        if (mToolbar != null) &#123;</div><div class="line">            //将Toolbar显示到界面</div><div class="line">            setSupportActionBar(mToolbar);</div><div class="line">        &#125;</div><div class="line">        if (mToolbarTitle != null) &#123;</div><div class="line">            //getTitle()的值是activity的android:lable属性值</div><div class="line">            mToolbarTitle.setText(getTitle());</div><div class="line">            //设置默认的标题不显示</div><div class="line">            getSupportActionBar().setDisplayShowTitleEnabled(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">        // Inflate the menu; this adds items to the action bar if it is present.</div><div class="line">        getMenuInflater().inflate(R.menu.activity_tool_bar, menu);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onOptionsItemSelected(MenuItem item) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        switch (item.getItemId()) &#123;</div><div class="line">            case R.id.action_item1:</div><div class="line">                ToastUtil.showToastShort(&quot;回到首页&quot;);</div><div class="line">                break;</div><div class="line">            case R.id.action_item2:</div><div class="line">                ToastUtil.showToastShort(&quot;分享&quot;);</div><div class="line">                break;</div><div class="line">            case R.id.action_item3:</div><div class="line">                ToastUtil.showToastShort(&quot;扫一扫&quot;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return super.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        /**</div><div class="line">         * 判断是否有Toolbar,并默认显示返回按钮</div><div class="line">         */</div><div class="line">        if(null != getToolbar() &amp;&amp; isShowBacking())&#123;</div><div class="line">            showBack();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取头部标题的TextView</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public TextView getToolbarTitle()&#123;</div><div class="line">        return mToolbarTitle;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 获取头部副标题的TextView</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public TextView getSubTitle()&#123;</div><div class="line">        return mToolbarSubTitle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置头部标题</div><div class="line">     * @param title</div><div class="line">     */</div><div class="line">    public void setToolBarTitle(CharSequence title) &#123;</div><div class="line">        if(mToolbarTitle != null)&#123;</div><div class="line">            mToolbarTitle.setText(title);</div><div class="line">        &#125;else&#123;</div><div class="line">            getToolbar().setTitle(title);</div><div class="line">            setSupportActionBar(getToolbar());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * this Activity of tool bar.</div><div class="line">     * 获取头部.</div><div class="line">     * @return support.v7.widget.Toolbar.</div><div class="line">     */</div><div class="line">    public Toolbar getToolbar() &#123;</div><div class="line">        return (Toolbar) findViewById(R.id.toolbar);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 版本号小于21的后退按钮图片</div><div class="line">     */</div><div class="line">    private void showBack()&#123;</div><div class="line">        //setNavigationIcon必须在setSupportActionBar(toolbar);方法后面加入</div><div class="line">        getToolbar().setNavigationIcon(R.mipmap.back);</div><div class="line">        getToolbar().setNavigationOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                onBackPressed();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 是否显示后退按钮,默认显示,可在子类重写该方法.</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowBacking()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在ToorBarActivity中写了ToorBar的实现，因为我们的ToolBar是include方式加入到子Activity中的，所以我们是按照正常的方式初始化ToolBar并写了它的一些方法。</p>
<p>最终我们的加载顺序是这样的：</p>
<p>1、先加载子Activity的Layout(包括ToolBar)<br>2、再加载顶部状态栏<br>3、再初始化ToolBar(findviewbyid)<br>4、再初始化其他控件(findviewbyid)</p>
<p>总体的过程就是这样，我这个BaseActivity比较简单，只是帮助入门者建立一个这样的构建思想，建立自己的框架概念和体系。</p>
<p>下一篇我会带大家一起封装一些常用的工具类+ButterKnife+retrofit+RXJava，敬请期待。</p>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897/AppFrame" target="_blank" rel="external">https://github.com/qht1003077897/AppFrame</a><br>个人博客地址：<a href="https://qht1003077897.github.io/" target="_blank" rel="external">https://qht1003077897.github.io/</a><br>QQ：1003077897</p>
<p>欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      博客出自：http://blog.csdn.net/u012534831
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="手把手" scheme="http://yoursite.com/tags/%E6%89%8B%E6%8A%8A%E6%89%8B/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>ListView源码分析</title>
    <link href="http://yoursite.com/2016/07/17/ListView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/17/ListView源码分析/</id>
    <published>2016-07-17T08:59:16.000Z</published>
    <updated>2017-07-17T09:18:19.539Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章没文字，只有两幅图，需要文字的请看：<a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="external"> Android ListView工作原理完全解析，带你从源码的角度彻底理解</a>。</p>
<p><img src="http://img.blog.csdn.net/20170717165745483?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170717170016126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUzNDgzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>自己总结了一下，加深对listview复用机制的理解。</p>
<hr>
<p>csdn地址：<a href="http://blog.csdn.net/u012534831" target="_blank" rel="external">http://blog.csdn.net/u012534831</a><br>github地址：<a href="https://github.com/qht1003077897" target="_blank" rel="external">https://github.com/qht1003077897</a><br>个人博客地址：<a href="https://qht1003077897.github.io" target="_blank" rel="external">https://qht1003077897.github.io</a><br>QQ：1003077897</p>
]]></content>
    
    <summary type="html">
    
      ListView源码分析，根据郭霖ListView源码分析总结而来，全文只有两幅图
    
    </summary>
    
      <category term="源码,Android" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81-Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
